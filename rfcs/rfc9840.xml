<?xml version='1.0' encoding='utf-8'?>
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" version="3" category="exp" docName="draft-irtf-iccrg-rledbat-10" number="9840" consensus="true" ipr="trust200902" obsoletes="" updates="" submissionType="IRTF" xml:lang="en" tocInclude="true" symRefs="true" sortRefs="true" prepTime="2025-09-18T09:46:54" indexInclude="true" scripts="Common,Latin" tocDepth="3">
  <link href="https://datatracker.ietf.org/doc/draft-irtf-iccrg-rledbat-10" rel="prev"/>
  <link href="https://dx.doi.org/10.17487/rfc9840" rel="alternate"/>
  <link href="urn:issn:2070-1721" rel="alternate"/>
  <front>
    <title abbrev="rLEDBAT">rLEDBAT: Receiver-Driven Low Extra Delay Background Transport for TCP</title>
    <seriesInfo name="RFC" value="9840" stream="IRTF"/>
    <author fullname="Marcelo Bagnulo" initials="M." surname="Bagnulo">
      <organization showOnFrontPage="true">Universidad Carlos III de Madrid</organization>
      <address>
        <email>marcelo@it.uc3m.es</email>
      </address>
    </author>
    <author fullname="Alberto García-Martínez" initials="A." surname="García-Martínez">
      <organization showOnFrontPage="true">Universidad Carlos III de Madrid</organization>
      <address>
        <email>alberto@it.uc3m.es</email>
      </address>
    </author>
    <author fullname="Gabriel Montenegro" initials="G." surname="Montenegro">
      <address>
        <email>g.e.montenegro@hotmail.com</email>
      </address>
    </author>
    <author fullname="Praveen Balasubramanian" initials="P." surname="Balasubramanian">
      <organization showOnFrontPage="true">Confluent</organization>
      <address>
        <email>pravb.ietf@gmail.com</email>
      </address>
    </author>
    <date month="09" year="2025"/>
    <workgroup>Internet Congestion Control</workgroup>
    <keyword>Congestion control</keyword>
    <keyword>scavenger/less-than-best-effort traffic</keyword>
    <abstract pn="section-abstract">
      <t indent="0" pn="section-abstract-1"> This document specifies receiver-driven Low Extra Delay Background Transport (rLEDBAT) -- a set of mechanisms that enable the execution of a less-than-best-effort congestion control algorithm for TCP at the receiver end. This document is a product of the Internet Congestion Control Research Group (ICCRG) of the Internet Research Task Force (IRTF).
      </t>
    </abstract>
    <boilerplate>
      <section anchor="status-of-memo" numbered="false" removeInRFC="false" toc="exclude" pn="section-boilerplate.1">
        <name slugifiedName="name-status-of-this-memo">Status of This Memo</name>
        <t indent="0" pn="section-boilerplate.1-1">
            This document is not an Internet Standards Track specification; it is
            published for examination, experimental implementation, and
            evaluation. 
        </t>
        <t indent="0" pn="section-boilerplate.1-2">
            This document defines an Experimental Protocol for the Internet
            community.  This document is a product of the Internet Research
            Task Force (IRTF).  The IRTF publishes the results of Internet-related
            research and development activities.  These results might not be
            suitable for deployment.  This RFC represents the consensus of the
            Internet Congestion Control Research Group of the Internet Research Task Force
            (IRTF).  Documents approved for publication by the IRSG are not
            candidates for any level of Internet Standard; see Section 2 of RFC
            7841.
        </t>
        <t indent="0" pn="section-boilerplate.1-3">
            Information about the current status of this document, any
            errata, and how to provide feedback on it may be obtained at
            <eref target="https://www.rfc-editor.org/info/rfc9840" brackets="none"/>.
        </t>
      </section>
      <section anchor="copyright" numbered="false" removeInRFC="false" toc="exclude" pn="section-boilerplate.2">
        <name slugifiedName="name-copyright-notice">Copyright Notice</name>
        <t indent="0" pn="section-boilerplate.2-1">
            Copyright (c) 2025 IETF Trust and the persons identified as the
            document authors. All rights reserved.
        </t>
        <t indent="0" pn="section-boilerplate.2-2">
            This document is subject to BCP 78 and the IETF Trust's Legal
            Provisions Relating to IETF Documents
            (<eref target="https://trustee.ietf.org/license-info" brackets="none"/>) in effect on the date of
            publication of this document. Please review these documents
            carefully, as they describe your rights and restrictions with
            respect to this document.
        </t>
      </section>
    </boilerplate>
    <toc>
      <section anchor="toc" numbered="false" removeInRFC="false" toc="exclude" pn="section-toc.1">
        <name slugifiedName="name-table-of-contents">Table of Contents</name>
        <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1">
          <li pn="section-toc.1-1.1">
            <t indent="0" keepWithNext="true" pn="section-toc.1-1.1.1"><xref derivedContent="1" format="counter" sectionFormat="of" target="section-1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-introduction">Introduction</xref></t>
          </li>
          <li pn="section-toc.1-1.2">
            <t indent="0" keepWithNext="true" pn="section-toc.1-1.2.1"><xref derivedContent="2" format="counter" sectionFormat="of" target="section-2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-conventions-and-terminology">Conventions and Terminology</xref></t>
          </li>
          <li pn="section-toc.1-1.3">
            <t indent="0" keepWithNext="true" pn="section-toc.1-1.3.1"><xref derivedContent="3" format="counter" sectionFormat="of" target="section-3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-motivations-for-rledbat">Motivations for rLEDBAT</xref></t>
          </li>
          <li pn="section-toc.1-1.4">
            <t indent="0" pn="section-toc.1-1.4.1"><xref derivedContent="4" format="counter" sectionFormat="of" target="section-4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-rledbat-mechanisms">rLEDBAT Mechanisms</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.4.2">
              <li pn="section-toc.1-1.4.2.1">
                <t indent="0" pn="section-toc.1-1.4.2.1.1"><xref derivedContent="4.1" format="counter" sectionFormat="of" target="section-4.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-controlling-the-receive-win">Controlling the Receive Window</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.4.2.1.2">
                  <li pn="section-toc.1-1.4.2.1.2.1">
                    <t indent="0" pn="section-toc.1-1.4.2.1.2.1.1"><xref derivedContent="4.1.1" format="counter" sectionFormat="of" target="section-4.1.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-avoiding-window-shrinking">Avoiding Window Shrinking</xref></t>
                  </li>
                  <li pn="section-toc.1-1.4.2.1.2.2">
                    <t indent="0" pn="section-toc.1-1.4.2.1.2.2.1"><xref derivedContent="4.1.2" format="counter" sectionFormat="of" target="section-4.1.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-setting-the-window-scale-op">Setting the Window Scale Option</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.4.2.2">
                <t indent="0" pn="section-toc.1-1.4.2.2.1"><xref derivedContent="4.2" format="counter" sectionFormat="of" target="section-4.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-measuring-delays">Measuring Delays</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.4.2.2.2">
                  <li pn="section-toc.1-1.4.2.2.2.1">
                    <t indent="0" pn="section-toc.1-1.4.2.2.2.1.1"><xref derivedContent="4.2.1" format="counter" sectionFormat="of" target="section-4.2.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-measuring-rtt-to-estimate-t">Measuring RTT to Estimate the Queuing Delay</xref></t>
                  </li>
                  <li pn="section-toc.1-1.4.2.2.2.2">
                    <t indent="0" pn="section-toc.1-1.4.2.2.2.2.1"><xref derivedContent="4.2.2" format="counter" sectionFormat="of" target="section-4.2.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-measuring-one-way-delay-to-">Measuring One-Way Delay to Estimate the Queuing Delay</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.4.2.3">
                <t indent="0" pn="section-toc.1-1.4.2.3.1"><xref derivedContent="4.3" format="counter" sectionFormat="of" target="section-4.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-detecting-packet-losses-and">Detecting Packet Losses and Retransmissions</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.5">
            <t indent="0" pn="section-toc.1-1.5.1"><xref derivedContent="5" format="counter" sectionFormat="of" target="section-5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-experiment-considerations">Experiment Considerations</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.5.2">
              <li pn="section-toc.1-1.5.2.1">
                <t indent="0" pn="section-toc.1-1.5.2.1.1"><xref derivedContent="5.1" format="counter" sectionFormat="of" target="section-5.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-status-of-the-experiment-at">Status of the Experiment at the Time of This Writing</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.6">
            <t indent="0" pn="section-toc.1-1.6.1"><xref derivedContent="6" format="counter" sectionFormat="of" target="section-6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-security-considerations">Security Considerations</xref></t>
          </li>
          <li pn="section-toc.1-1.7">
            <t indent="0" pn="section-toc.1-1.7.1"><xref derivedContent="7" format="counter" sectionFormat="of" target="section-7"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-iana-considerations">IANA Considerations</xref></t>
          </li>
          <li pn="section-toc.1-1.8">
            <t indent="0" pn="section-toc.1-1.8.1"><xref derivedContent="8" format="counter" sectionFormat="of" target="section-8"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-references">References</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.8.2">
              <li pn="section-toc.1-1.8.2.1">
                <t indent="0" pn="section-toc.1-1.8.2.1.1"><xref derivedContent="8.1" format="counter" sectionFormat="of" target="section-8.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-normative-references">Normative References</xref></t>
              </li>
              <li pn="section-toc.1-1.8.2.2">
                <t indent="0" pn="section-toc.1-1.8.2.2.1"><xref derivedContent="8.2" format="counter" sectionFormat="of" target="section-8.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-informative-references">Informative References</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.9">
            <t indent="0" pn="section-toc.1-1.9.1"><xref derivedContent="Appendix A" format="default" sectionFormat="of" target="section-appendix.a"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-rledbat-pseudocode">rLEDBAT Pseudocode</xref></t>
          </li>
          <li pn="section-toc.1-1.10">
            <t indent="0" pn="section-toc.1-1.10.1"><xref derivedContent="" format="none" sectionFormat="of" target="section-appendix.b"/><xref derivedContent="" format="title" sectionFormat="of" target="name-acknowledgments">Acknowledgments</xref></t>
          </li>
          <li pn="section-toc.1-1.11">
            <t indent="0" pn="section-toc.1-1.11.1"><xref derivedContent="" format="none" sectionFormat="of" target="section-appendix.c"/><xref derivedContent="" format="title" sectionFormat="of" target="name-authors-addresses">Authors' Addresses</xref></t>
          </li>
        </ul>
      </section>
    </toc>
  </front>
  <middle>
    <section numbered="true" toc="include" removeInRFC="false" pn="section-1">
      <name slugifiedName="name-introduction">Introduction</name>
      <t indent="0" pn="section-1-1">LEDBAT (Low Extra Delay Background Transport) <xref target="RFC6817" format="default" sectionFormat="of" derivedContent="RFC6817"/> is a congestion control algorithm used for less-than-best-effort (LBE) traffic.</t>
      <t indent="0" pn="section-1-2">When LEDBAT traffic shares a bottleneck with other traffic using standard congestion control algorithms (for example, TCP traffic using CUBIC <xref target="RFC9438" format="default" sectionFormat="of" derivedContent="RFC9438"/>, hereafter referred to as "standard-TCP" for short), it reduces its sending rate earlier and more aggressively than standard-TCP congestion control, allowing other non-background traffic to use more of the available capacity. In the absence of competing traffic, LEDBAT aims to make efficient use of the available capacity, while keeping the queuing delay within predefined bounds.</t>
      <t indent="0" pn="section-1-3">LEDBAT reacts to both packet loss and variations in delay.  With respect to packet loss, LEDBAT reacts with a multiplicative decrease, similar to most TCP congestion controllers. Regarding delay, LEDBAT aims for a target queuing delay. When the measured current queuing delay is below the target, LEDBAT increases the sending rate, and when the delay is above the target, it reduces the sending rate. LEDBAT estimates the queuing delay by subtracting the measured current one-way delay from the estimated base one-way delay (i.e., the one-way delay in the absence of queues). </t>
      <t indent="0" pn="section-1-4">The LEDBAT specification <xref target="RFC6817" format="default" sectionFormat="of" derivedContent="RFC6817"/> defines the LEDBAT congestion control algorithm, implemented in the sender to control its sending rate. LEDBAT is specified in a protocol-agnostic and layer-agnostic manner.</t>
      <t indent="0" pn="section-1-5">LEDBAT++ <xref target="I-D.irtf-iccrg-ledbat-plus-plus" format="default" sectionFormat="of" derivedContent="LEDBAT++"/> is also an LBE congestion control algorithm that is inspired by LEDBAT while addressing several problems identified with the original LEDBAT specification. In particular, the differences between LEDBAT and LEDBAT++ include the following:</t>
      <ol spacing="normal" type="%i)" indent="adaptive" start="1" pn="section-1-6">
 <li pn="section-1-6.1" derivedCounter="i)">LEDBAT++ uses the round-trip time (RTT) (as opposed to the one-way delay used in LEDBAT) to estimate the queuing delay.</li>
        <li pn="section-1-6.2" derivedCounter="ii)">LEDBAT++ uses an additive increase/multiplicative decrease algorithm to achieve inter-LEDBAT++ fairness and avoid the latecomer advantage observed in LEDBAT.</li>
        <li pn="section-1-6.3" derivedCounter="iii)">LEDBAT++ performs periodic slowdowns to improve the measurement of the base delay.</li>
        <li pn="section-1-6.4" derivedCounter="iv)">LEDBAT++ is defined for TCP.</li>
      </ol>
      <t indent="0" pn="section-1-7">In this specification, we describe receiver-driven Low Extra Delay Background Transport (rLEDBAT) -- a set of mechanisms that enable the execution of an LBE delay-based congestion control algorithm such as LEDBAT or LEDBAT++ at the receiver end of a TCP connection.</t>
      <t indent="0" pn="section-1-8"> The consensus of the Internet Congestion Control Research Group (ICCRG) is to publish this document to encourage further experimentation and review of rLEDBAT. This document is not an IETF product and is not an Internet Standards Track specification. The status of this document is Experimental. In <xref target="sect-5" format="default" sectionFormat="of" derivedContent="Section 5"/> ("<xref target="sect-5" format="title" sectionFormat="of" derivedContent="Experiment Considerations"/>"), we describe the purpose of the experiment and its current status.  </t>
    </section>
    <section numbered="true" toc="include" removeInRFC="false" pn="section-2">
      <name slugifiedName="name-conventions-and-terminology">Conventions and Terminology</name>
      <t indent="0" pn="section-2-1">The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>",
       "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>",
       "<bcp14>SHALL NOT</bcp14>", "<bcp14>SHOULD</bcp14>",
       "<bcp14>SHOULD NOT</bcp14>",
       "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>",
       "<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this document
       are to be interpreted as described in BCP 14
       <xref target="RFC2119" format="default" sectionFormat="of" derivedContent="RFC2119"/> <xref target="RFC8174" format="default" sectionFormat="of" derivedContent="RFC8174"/> when, and only
       when, they appear in all capitals, as shown here.</t>
      <t indent="0" pn="section-2-2">We use the following abbreviations throughout the text and include them here for the reader's convenience:</t>
      <dl spacing="normal" newline="false" indent="3" pn="section-2-3">
        <dt pn="section-2-3.1">RCV.WND:</dt>
        <dd pn="section-2-3.2">The value included in the Receive Window field of
        the TCP header (the computation of which is modified by its
        specification).</dd>
        <dt pn="section-2-3.3">SND.WND:</dt>
        <dd pn="section-2-3.4">The TCP sender's window.</dd>
        <dt pn="section-2-3.5">cwnd:</dt>
        <dd pn="section-2-3.6">The congestion window as computed by the congestion
        control algorithm running at the TCP sender.</dd>
        <dt pn="section-2-3.7">RLWND:</dt>
        <dd pn="section-2-3.8">The window value calculated by the rLEDBAT algorithm.</dd>
        <dt pn="section-2-3.9">fcwnd:</dt>
        <dd pn="section-2-3.10">The value that a standard-TCP receiver compliant with
        <xref target="RFC9293" format="default" sectionFormat="of" derivedContent="RFC9293"/>
        calculates to set in the receive window for flow control
        purposes.</dd>
        <dt pn="section-2-3.11">RCV.HGH:</dt>
        <dd pn="section-2-3.12">The highest sequence number corresponding to a
        received byte of data at one point in time.</dd>
        <dt pn="section-2-3.13">TSV.HGH:</dt>
        <dd pn="section-2-3.14">The Timestamp Value (TSval) <xref target="RFC7323" format="default" sectionFormat="of" derivedContent="RFC7323"/> corresponding to the
        segment in which RCV.HGH was carried at that point in time.</dd>
        <dt pn="section-2-3.15">SEG.SEQ:</dt>
        <dd pn="section-2-3.16">The sequence number of the last received segment.</dd>
        <dt pn="section-2-3.17">TSV.SEQ:</dt>
        <dd pn="section-2-3.18">The TSval of the last received segment.</dd>
      </dl>
    </section>
    <section numbered="true" toc="include" removeInRFC="false" pn="section-3">
      <name slugifiedName="name-motivations-for-rledbat">Motivations for rLEDBAT</name>
      <t indent="0" pn="section-3-1">rLEDBAT enables new use cases and new deployment models, fostering the use of LBE traffic. The following scenarios are enabled by rLEDBAT:
      </t>
      <dl spacing="normal" newline="true" indent="3" pn="section-3-2">
        <dt pn="section-3-2.1">Content Delivery Networks (CDNs) and more sophisticated file distribution scenarios:</dt>
        <dd pn="section-3-2.2">Consider the case where the source of a file to be distributed (e.g., a software developer that wishes to distribute a software update) would prefer to use LBE and enables LEDBAT/LEDBAT++ in the servers containing the source file. However, because the file is being distributed through a CDN that does not implement LBE congestion control, the result is that the file transfers originated from CDN surrogates will not be using LBE. Interestingly enough, in the case of the software update, the developer may also control the software performing the download in the client (the receiver of the file), but because current LEDBAT/LEDBAT++ are sender-based algorithms, controlling the client is not enough to enable LBE congestion control in the communication.  rLEDBAT would enable the use of an LBE traffic class for file distribution in this setup.</dd>
        <dt pn="section-3-2.3">Interference from proxies and other middleboxes:</dt>
        <dd pn="section-3-2.4">Proxies and other middleboxes are commonplace in the Internet. For instance, in the case of mobile networks, proxies are frequently used. In the case of enterprise networks, it is common to deploy corporate proxies for filtering and firewalling. In the case of satellite links, Performance Enhancing Proxies (PEPs) are deployed to mitigate the effect of long delays in a TCP connection. These proxies terminate the TCP connection on both ends and prevent the use of LBE congestion control in the segment between the proxy and the sink of the content, the client. By enabling rLEDBAT, clients can then enable LBE traffic between them and the proxy.</dd>
        <dt pn="section-3-2.5">Receiver-defined preferences:</dt>
        <dd pn="section-3-2.6">Frequently, the access link is the communication bottleneck. This is particularly true in the case of mobile devices. It is then especially relevant for mobile devices to properly manage the capacity of the access link. With current technologies, it is possible for the mobile device to use different congestion control algorithms expressing different preferences for the traffic. For instance, a device can choose to use standard-TCP for some traffic and use LEDBAT/LEDBAT++ for other traffic. However, this would only affect the outgoing traffic, since both standard-TCP and LEDBAT/LEDBAT++ are driven by the sender. The mobile device has no means to manage the traffic in the downlink, which is, in most cases, the communication bottleneck for a typical "eyeball" end user.  rLEDBAT enables the mobile device to selectively use an LBE traffic class for some of the incoming traffic. For instance, by using rLEDBAT, a user can use regular standard-TCP/UDP for a video stream (e.g., YouTube) and use rLEDBAT for other background file downloads.</dd>
      </dl>
    </section>
    <section numbered="true" toc="include" removeInRFC="false" pn="section-4">
      <name slugifiedName="name-rledbat-mechanisms">rLEDBAT Mechanisms</name>
      <t indent="0" pn="section-4-1">rLEDBAT provides the mechanisms to implement an LBE congestion control algorithm at the receiver end of a TCP connection. The rLEDBAT receiver controls the sender's rate through the receive window announced by the receiver in the TCP header.</t>
      <t indent="0" pn="section-4-2">rLEDBAT assumes that the sender is a standard-TCP sender.  rLEDBAT does not require any rLEDBAT-specific modifications to the TCP sender. The envisioned deployment model for rLEDBAT is that the clients implement rLEDBAT and this enables rLEDBAT in communications with existing standard-TCP senders.  In particular, the sender <bcp14>MUST</bcp14> implement <xref target="RFC9293" format="default" sectionFormat="of" derivedContent="RFC9293"/> and also <bcp14>MUST</bcp14> implement the TCP Timestamps (TS) option as defined in <xref target="RFC7323" format="default" sectionFormat="of" derivedContent="RFC7323"/>. Also, the sender should implement some of the standard congestion control mechanisms, such as CUBIC <xref target="RFC9438" format="default" sectionFormat="of" derivedContent="RFC9438"/> or NewReno <xref target="RFC5681" format="default" sectionFormat="of" derivedContent="RFC5681"/> <xref target="RFC6582" format="default" sectionFormat="of" derivedContent="RFC6582"/>.</t>
      <t indent="0" pn="section-4-3">rLEDBAT does not define a new congestion control algorithm. The definition of the actual LBE congestion control algorithm executed in the rLEDBAT receiver is beyond the scope of this document. The rLEDBAT receiver <bcp14>MUST</bcp14> use an LBE congestion control algorithm. Because rLEDBAT assumes a standard-TCP sender, the sender will be using a "best effort" congestion control algorithm (such as CUBIC or NewReno). Since rLEDBAT uses the receive window to control the sender's rate and the sender calculates the sender's window as the minimum of the receive window and the congestion window, rLEDBAT will only be effective as long as the congestion control algorithm executed in the receiver yields a smaller window than the one calculated by the sender. This is normally the case when the receiver is using an LBE congestion control algorithm. The rLEDBAT receiver <bcp14>SHOULD</bcp14> use the LEDBAT congestion control algorithm <xref target="RFC6817" format="default" sectionFormat="of" derivedContent="RFC6817"/> or the LEDBAT++ congestion control algorithm <xref target="I-D.irtf-iccrg-ledbat-plus-plus" format="default" sectionFormat="of" derivedContent="LEDBAT++"/>.  rLEDBAT <bcp14>MAY</bcp14> use other LBE congestion control algorithms defined elsewhere. Irrespective of which congestion control algorithm is executed in the receiver, a rLEDBAT connection will never be more aggressive than standard-TCP, since it is always bounded by the congestion control algorithm executed at the sender.</t>
      <t indent="0" pn="section-4-4">rLEDBAT is essentially composed of three types of mechanisms, namely 
those that provide the means to measure the packet delay (either the RTT or the one-way delay, depending on the selected algorithm), mechanisms to detect packet loss, and the means to manipulate the receive window to control the sender's rate. The first two provide input to the LBE congestion control algorithm, while the third uses the congestion window computed by the LBE congestion control algorithm to manipulate the receive window, as depicted in <xref target="fig1" format="default" sectionFormat="of" derivedContent="Figure 1"/>.</t>
      <figure anchor="fig1" align="left" suppress-title="false" pn="figure-1">
        <name slugifiedName="name-the-rledbat-architecture">The rLEDBAT Architecture</name>
        <artwork align="center" name="" type="" alt="" pn="section-4-5.1">
+------------------------------------------+
|   TCP Receiver                           |
|                      +-----------------+ |
|                      |  +------------+ | |
|   +---------------------|     RTT    | | |
|   |                  |  | Estimation | | |
|   |                  |  +------------+ | |
|   |                  |                 | |
|   |                  |  +------------+ | |
|   |      +--------------| Loss, RTX  | | |
|   |      |           |  | Detection  | | |
|   |      |           |  +------------+ | |
|   v      v           |                 | |
| +----------------+   |                 | |
| | LBE Congestion |   |    rLEDBAT      | |
| |    Control     |   |                 | |
| +----------------+   |                 | |
|       |              |  +------------+ | |
|       |              |  | RCV.WND    | | |
|       +----------------&gt;| Control    | | |
|                      |  +------------+ | |
|                      +-----------------+ |
+------------------------------------------+
</artwork>
      </figure>
      <t indent="0" pn="section-4-6">We next describe each of the rLEDBAT components.</t>
      <section numbered="true" toc="include" removeInRFC="false" pn="section-4.1">
        <name slugifiedName="name-controlling-the-receive-win">Controlling the Receive Window</name>
        <t indent="0" pn="section-4.1-1">rLEDBAT uses the TCP receive window (RCV.WND) to enable the receiver to control the sender's rate.  <xref target="RFC9293" format="default" sectionFormat="of" derivedContent="RFC9293"/> specifies that the RCV.WND is used to announce the available receive buffer to the sender for flow control purposes. In order to avoid confusion, we will call fcwnd the value that a standard-TCP receiver compliant with <xref target="RFC9293" format="default" sectionFormat="of" derivedContent="RFC9293"/> calculates to set in the receive window for flow control purposes. We call RLWND the window value calculated by the rLEDBAT algorithm, and we call RCV.WND the value actually included in the Receive Window field of the TCP header. For a receiver compliant with <xref target="RFC9293" format="default" sectionFormat="of" derivedContent="RFC9293"/>, RCV.WND == fcwnd.</t>
        <t indent="0" pn="section-4.1-2">In the case of the rLEDBAT receiver, this receiver <bcp14>MUST NOT</bcp14> set the RCV.WND to a value larger than fcwnd and <bcp14>SHOULD</bcp14> set the RCV.WND to the minimum of RLWND and fcwnd, honoring both.</t>
        <t indent="0" pn="section-4.1-3">When using rLEDBAT, two congestion controllers are in action in the flow of data from the sender to the receiver, namely the TCP congestion control algorithm on the sender side and the LBE congestion control  algorithm executed in the receiver and conveyed to the sender through the RCV.WND. In the normal TCP operation, the sender uses the minimum of the cwnd and the RCV.WND to calculate the SND.WND. This is also true for rLEDBAT, as the sender is a regular TCP sender. This guarantees that the rLEDBAT flow will never transmit more aggressively than a standard-TCP flow, as the sender's congestion window limits the sending rate. Moreover, because an LBE congestion control algorithm such as LEDBAT/LEDBAT++ is designed to react earlier and more aggressively to congestion than regular TCP congestion control, the RLWND contained in the TCP RCV.WND field will generally be smaller than the congestion window calculated by the TCP sender, implying that the rLEDBAT congestion control algorithm  will be effectively controlling the sender's window. One exception to this scenario is that at the beginning of the connection, when there is no information to set RLWND, RLWND is set to its maximum value, so that the sending rate of the sender is governed by the flow control algorithm of the receiver and the TCP slow start mechanism of the sender.</t>
        <t indent="0" pn="section-4.1-4">In summary, the sender's window is SND.WND = min(cwnd, RLWND, fcwnd)</t>
        <section numbered="true" toc="include" removeInRFC="false" pn="section-4.1.1">
          <name slugifiedName="name-avoiding-window-shrinking">Avoiding Window Shrinking</name>
          <t indent="0" pn="section-4.1.1-1">The LEDBAT/LEDBAT++ algorithm executed in a rLEDBAT receiver increases or decreases RLWND according to congestion signals (variations in the estimated queuing delay and packet loss). 
			
			If RLWND is decreased and directly announced in RCV.WND, this could lead to an announced window that is smaller than what is currently in use. This so-called "shrinking the window" is discouraged as per <xref target="RFC9293" format="default" sectionFormat="of" derivedContent="RFC9293"/>, as it may cause unnecessary packet loss and performance penalties. To be consistent with <xref target="RFC9293" format="default" sectionFormat="of" derivedContent="RFC9293"/>, the rLEDBAT receiver <bcp14>SHOULD NOT</bcp14> shrink the receive window. </t>
          <t indent="0" pn="section-4.1.1-2">In order to avoid window shrinking, the receiver <bcp14>MUST</bcp14> only reduce RCV.WND by the number of bytes contained in a received data packet. This may fall short to honor the new calculated value of the RLWND immediately. However, the receiver <bcp14>SHOULD</bcp14> progressively reduce the advertised RCV.WND, always honoring that the reduction is less than or equal to the received bytes, until the target window determined by the rLEDBAT algorithm is reached. 
This implies that it may take up to one RTT for the rLEDBAT receiver to drain enough in-flight bytes to completely close its receive window without shrinking it. This is sufficient to honor the window output from the LEDBAT/LEDBAT++ algorithms, since they are only allowed to perform at most one multiplicative decrease per RTT.</t>
        </section>
        <section numbered="true" toc="include" removeInRFC="false" pn="section-4.1.2">
          <name slugifiedName="name-setting-the-window-scale-op">Setting the Window Scale Option</name>
          <t indent="0" pn="section-4.1.2-1">The Window Scale (WS) option <xref target="RFC7323" format="default" sectionFormat="of" derivedContent="RFC7323"/> is a means to increase the maximum window size permitted by the receive window. The WS option defines a scale factor that restricts the granularity of the receive window that can be announced. This means that the rLEDBAT client will have to accumulate the increases resulting from multiple received packets and only convey a change in the window when the accumulated sum of increases is equal to or higher than one increase step as imposed by the scaling factor according to the WS option in place for the TCP connection.</t>
          <t indent="0" pn="section-4.1.2-2">Changes in the receive window that are smaller than 1 MSS (Maximum Segment Size) are unlikely to have any immediate impact on the sender's rate. As usual, TCP's segmentation practice results in sending full segments (i.e., segments of size equal to the MSS). <xref target="RFC7323" format="default" sectionFormat="of" derivedContent="RFC7323"/>, which defines the WS option, specifies that allowed values for the WS option are between 0 and 14. Assuming an MSS of around 1500 bytes, WS option values between 0 and 11 result in the receive window being expressed in units that are about 1 MSS or smaller. So, WS option values between 0 and 11 have no impact in rLEDBAT (unless packets smaller than the MSS are being exchanged).</t>
          <t indent="0" pn="section-4.1.2-3">WS option values higher than 11 can affect the dynamics of rLEDBAT, since control may become too coarse (e.g., with a WS option value of 14, a change in one unit of the receive window implies a change of 10 MSS in the effective window).
</t>
          <t indent="0" pn="section-4.1.2-4">For the above reasons, the rLEDBAT client <bcp14>SHOULD</bcp14> set WS option values lower than 12. Additional experimentation is required to explore the impact of larger WS values on rLEDBAT dynamics.</t>
          <t indent="0" pn="section-4.1.2-5">Note that the recommendation for rLEDBAT to set the WS option values to lower values does not preclude communication with servers that set the WS option values to larger values, since WS option values are set independently for each direction of the TCP connection.</t>
        </section>
      </section>
      <section numbered="true" toc="include" removeInRFC="false" pn="section-4.2">
        <name slugifiedName="name-measuring-delays">Measuring Delays</name>
        <t indent="0" pn="section-4.2-1">Both LEDBAT and LEDBAT++ measure base and current delays to estimate the queuing delay. LEDBAT uses the one-way delay, while LEDBAT++ uses the RTT. In the next sections, we describe how rLEDBAT mechanisms enable the receiver to measure the one-way delay or the RTT -- whichever is needed, depending on the congestion control algorithm used.</t>
        <section numbered="true" toc="include" removeInRFC="false" pn="section-4.2.1">
          <name slugifiedName="name-measuring-rtt-to-estimate-t">Measuring RTT to Estimate the Queuing Delay</name>
          <t indent="0" pn="section-4.2.1-1">LEDBAT++ uses the RTT to estimate the queuing delay. In order to estimate the queuing delay using RTT, the rLEDBAT receiver estimates the base RTT (i.e., the constant components of RTT) and also measures the current RTT. By subtracting these two values, we obtain the queuing delay to be used by the rLEDBAT controller.</t>
          <t indent="0" pn="section-4.2.1-2">LEDBAT++ discovers the base RTT (RTTb) by taking the minimum value of the measured RTTs over a period of time. The current RTT (RTTc) is estimated using a number of recent samples and applying a filter, such as the minimum (or the mean) of the last k samples. Using RTT to estimate the queuing delay has a number of shortcomings and difficulties, as discussed below.</t>
          <t indent="0" pn="section-4.2.1-3">The queuing delay measured using RTT also includes the queuing delay experienced by the return packets in the direction from the rLEDBAT receiver to the sender. This is a fundamental limitation of this approach. The impact of this limitation is that the rLEDBAT controller will also react to congestion in the reverse path direction, resulting in an even more conservative mechanism.</t>
          <t indent="0" pn="section-4.2.1-4">In order to measure RTT, the rLEDBAT client <bcp14>MUST</bcp14> enable the TS option <xref target="RFC7323" format="default" sectionFormat="of" derivedContent="RFC7323"/>. By matching the TSval carried in outgoing packets with the Timestamp Echo Reply (TSecr) value <xref target="RFC7323" format="default" sectionFormat="of" derivedContent="RFC7323"/> observed in incoming packets, it is possible to measure RTT. This allows the rLEDBAT receiver to measure RTT even if it is acting as a pure receiver. In a pure receiver, there is no data flowing from the rLEDBAT receiver to the sender, making it impossible to match data packets with Acknowledgment packets to measure RTT, in contrast to what is usually done in TCP for other purposes.</t>
          <t indent="0" pn="section-4.2.1-5">Depending on the frequency of the local clock used to generate the values included in the TS option, several packets may carry the same TSval. If that happens, the rLEDBAT receiver will be unable to match the different outgoing packets carrying the same TSval with the different incoming packets also carrying the same TSecr value. However, it is not necessary for rLEDBAT to use all packets to estimate RTT, and sampling a subset of in-flight packets per RTT is enough to properly assess the queuing delay. RTT <bcp14>MUST</bcp14> then be calculated as the time since the first packet with a given TSval was sent and the first packet that was received with the same value contained in the TSecr. Other packets with repeated TS values <bcp14>SHOULD NOT</bcp14> be used for RTT calculations. </t>
          <t indent="0" pn="section-4.2.1-6">Several issues must be addressed in order to avoid an artificial increase in the observed RTT. Different issues emerge, depending on whether the
rLEDBAT-capable host is sending data packets or pure ACKs to measure RTT. We next consider these issues separately.</t>
          <section numbered="true" toc="exclude" removeInRFC="false" pn="section-4.2.1.1">
            <name slugifiedName="name-measuring-rtt-when-sending-">Measuring RTT When Sending Pure ACKs</name>
            <t indent="0" pn="section-4.2.1.1-1">In this scenario, the rLEDBAT node (node A) sends a pure ACK to the other endpoint of the TCP connection (node B), including the TS option. Upon the reception of the TS option, host B will copy the value of the TSval into the TSecr field of the TS option and include that option in the next data packet towards host A. However, there are two reasons why B may not send a packet immediately back to A, artificially increasing the measured RTT. The first reason is when A has no data to send. 
The second is when A has no available window to put more packets in flight. We next describe how each of these cases is addressed.</t>
            <t indent="0" pn="section-4.2.1.1-2">The case where host B has no data to send when it receives the pure Acknowledgment is expected to be rare in the rLEDBAT use cases.  rLEDBAT will be used mostly for background file transfers, so the expected common case is that the sender will have data to send throughout the lifetime of the communication. However, if, for example, the file is structured in blocks of data, it may be the case that the sender will seldom have to wait until the next block is available to proceed with the data transfer. To address this situation, the filter used by the congestion control algorithm executed in the receiver <bcp14>SHOULD</bcp14> discard outliers (e.g., a MIN filter <xref target="RFC6817" format="default" sectionFormat="of" derivedContent="RFC6817"/> would achieve this) when measuring RTT using pure ACK packets.</t>
            <t indent="0" pn="section-4.2.1.1-3">This limitation of the sender's window can come from either the TCP congestion window in host B or the announced receive window from rLEDBAT in host A. Normally, the receive window will be the one to limit the sender's transmission rate, since the LBE congestion control algorithm used by the rLEDBAT node is designed to be more restrictive on the sender's rate than standard-TCP. If the limiting factor is the congestion window in the sender, it is less relevant if rLEDBAT further reduces the receive window due to a bloated RTT measurement, since the rLEDBAT node is not actively controlling the sender's rate. Nevertheless, the proposed approach to discard larger samples would also address this issue.</t>
            <t indent="0" pn="section-4.2.1.1-4">To address the case in which the limiting factor is the receive window announced by rLEDBAT, the congestion control algorithm at the receiver <bcp14>SHOULD</bcp14> discard RTT measurements during the window reduction phase that are triggered by pure ACK packets. The rLEDBAT receiver is aware of whether a given TSval was sent in a pure ACK packet where the window was reduced, and if so, it can discard the corresponding RTT measurement. </t>
          </section>
          <section numbered="true" toc="exclude" removeInRFC="false" pn="section-4.2.1.2">
            <name slugifiedName="name-measuring-rtt-when-sending-d">Measuring RTT When Sending Data Packets</name>
            <t indent="0" pn="section-4.2.1.2-1">In the case that the rLEDBAT node is sending data packets and matching them with pure ACKs to measure RTT, a factor that can artificially increase the RTT measured is the presence of delayed Acknowledgments. 
		According to the TS option generation rules <xref target="RFC7323" format="default" sectionFormat="of" derivedContent="RFC7323"/>,  
		the value included in the TSecr for a delayed ACK is the one in the TSval field of the earliest unacknowledged segment.
		This may artificially increase the measured RTT. </t>
            <t indent="0" pn="section-4.2.1.2-2">If both endpoints of the connection are sending data packets, Acknowledgments are piggybacked onto the data packets and they are not delayed. Delayed ACKs only increase RTT measurements in the case that the sender has no data to send. Since the expected use case for rLEDBAT is that the sender will be sending background traffic to the rLEDBAT receiver, the cases where delayed ACKs increase the measured RTT are expected to be rare.</t>
            <t indent="0" pn="section-4.2.1.2-3">Nevertheless, measurements based on data packets from the rLEDBAT node matching pure ACKs from the other end will result in an increased RTT sample. The additional increase in the measured RTT will be up to 500 ms. This is because delayed ACKs are generated every second data packet received and not delayed more than 500 ms according to <xref target="RFC9293" format="default" sectionFormat="of" derivedContent="RFC9293"/>. The rLEDBAT receiver <bcp14>MAY</bcp14> discard RTT measurements done using data packets from the rLEDBAT receiver and matching pure ACKs, especially if it has recent measurements done using other packet combinations. Applying a filter (e.g., a MIN filter) that discards outliers would also address this issue.</t>
          </section>
        </section>
        <section numbered="true" toc="include" removeInRFC="false" pn="section-4.2.2">
          <name slugifiedName="name-measuring-one-way-delay-to-">Measuring One-Way Delay to Estimate the Queuing Delay</name>
          <t indent="0" pn="section-4.2.2-1">The LEDBAT algorithm uses the one-way delay of packets as input. A TCP receiver can measure the delay of incoming packets directly (as opposed to the sender-based LEDBAT, where the receiver measures the one-way delay and needs to convey it to the sender).</t>
          <t indent="0" pn="section-4.2.2-2">In the case of TCP, the receiver can use the TS option to measure the one-way delay by subtracting the timestamp contained in the incoming packet from the local time at which the packet has arrived. As noted in <xref target="RFC6817" format="default" sectionFormat="of" derivedContent="RFC6817"/>, the clock offset between the sender's clock and the receiver's clock does not affect the LEDBAT operation, since LEDBAT uses the difference between the base one-way delay and the current one-way delay to estimate the queuing delay, effectively "canceling out" the clock offset error in the queuing delay estimation. There are, however, two other issues that the rLEDBAT receiver needs to take into account in order to properly estimate the one-way delay, namely the units in which the received timestamps are expressed and the clock skew. These issues are addressed below.</t>
          <t indent="0" pn="section-4.2.2-3">In order to measure the one-way delay using TCP timestamps, the rLEDBAT receiver first needs to discover the units of values in the TS option and then needs to account for the skew between the two endpoint clocks. Note that a mismatch of 100 ppm (parts per million) in the estimation of the sender's clock rate accounts for 6 ms of variation per minute in the measured delay. This is just one order of magnitude below the target delay set by rLEDBAT (or potentially more if the target is set to lower values, which is possible). Typical skew for untrained clocks is reported to be around 100-200 ppm <xref target="RFC6817" format="default" sectionFormat="of" derivedContent="RFC6817"/>.</t>
          <t indent="0" pn="section-4.2.2-4">In order to learn both the TS units and the clock skew, the rLEDBAT receiver measures how much local time has elapsed between two packets with different TS values issued by the sender. By comparing the local time difference and the TS value difference, the receiver can assess the TS units and relative clock skews. In order for this to be accurate, the packets carrying the different TS values should experience equal (or at least similar) delay when traveling from the sender to the receiver, as any difference in the experienced delays would introduce an error in the unit/skew estimation. One possible approach is to select packets that experienced minimal delay (i.e., queuing delay close to zero) to make the estimations.</t>
          <t indent="0" pn="section-4.2.2-5">An additional difficulty regarding the estimation of the TS units and clock skew in the context of (r)LEDBAT is that the LEDBAT congestion controller actions directly affect the (queuing) delay experienced by packets. In particular, if there is an error in the estimation of the TS units/skew, the LEDBAT controller will attempt to compensate for it by reducing/increasing the load. The result is that the LEDBAT operation interferes with the TS units/clock skew measurements. Because of this, measurements are more accurate when there is no traffic in the connection (in addition to the packets used for the measurements). The problem is that the receiver is unaware of whether the sender is injecting traffic at any point in time; it is therefore unable to use these quiet intervals to perform measurements. The receiver can, however, force periodic slowdowns, reducing the
announced receive window to a few packets and performing the measurements at that time.</t>
          <t indent="0" pn="section-4.2.2-6">It is possible for the rLEDBAT receiver to perform multiple measurements to assess both the TS units and the relative clock skew during the lifetime of the connection, in order to obtain more accurate results. Clock skew measurements are more accurate if the time period used to discover the skew is larger, as the impact of the skew becomes more apparent.  It is a reasonable approach for the rLEDBAT receiver to perform an early discovery of the TS units (and the clock skew) using the first few packets of the TCP connection and then improve the accuracy of the TS units/clock skew estimation using periodic measurements later in the lifetime of the connection. </t>
        </section>
      </section>
      <section numbered="true" toc="include" removeInRFC="false" pn="section-4.3">
        <name slugifiedName="name-detecting-packet-losses-and">Detecting Packet Losses and Retransmissions</name>
        <t indent="0" pn="section-4.3-1">The rLEDBAT receiver is capable of detecting retransmitted packets as follows. We call RCV.HGH the highest sequence number corresponding to a received byte of data (not assuming that all bytes with smaller sequence numbers have been received already, there may be holes), and we call TSV.HGH the TSval corresponding to the segment in which that byte was carried. SEG.SEQ stands for the sequence number of a newly received segment, and we call TSV.SEQ the TSval of the newly received segment.</t>
        <t indent="0" pn="section-4.3-2">If SEG.SEQ &lt; RCV.HGH and TSV.SEQ &gt; TSV.HGH, then the newly received segment is a retransmission. This is so because the newly received segment was generated later than another already-received segment that contained data with a larger sequence number. This means that this segment was lost and was retransmitted.</t>
        <t indent="0" pn="section-4.3-3">The proposed mechanism to detect retransmissions at the receiver fails when there are window tail drops. If all packets in the tail of the window are lost, the receiver will not be able to detect a mismatch between the sequence numbers of the packets and the order of the timestamps. In this case, rLEDBAT will not react to losses; however, the TCP congestion controller at the sender will, most likely reducing its window to 1 MSS and taking over the control of the sending rate until slow start ramps up and catches the current value of the rLEDBAT window.</t>
      </section>
    </section>
    <section numbered="true" anchor="sect-5" toc="include" removeInRFC="false" pn="section-5">
      <name slugifiedName="name-experiment-considerations">Experiment Considerations</name>
      <t indent="0" pn="section-5-1">The status of this document is Experimental. The general purpose of the proposed experiment is to gain more experience running rLEDBAT over different network paths to see if the proposed rLEDBAT parameters perform well in different situations. Specifically, we would like to learn about the following aspects of the rLEDBAT mechanism: </t>
      <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-5-2">
        <li pn="section-5-2.1">
          <t indent="0" pn="section-5-2.1.1">Interaction between the sender's and receiver's congestion control algorithms.  rLEDBAT posits that because the rLEDBAT receiver is using a less-than-best-effort congestion control algorithm, the receiver's congestion control algorithm will expose a smaller congestion window (conveyed through the receive window) than the one resulting from the congestion control algorithm executed at the sender. One of the purposes of the experiment is to learn how these two algorithms
interact and if the assumption that the receiver side is always controlling the sender's rate (and making rLEDBAT effective) holds. The experiment should include the different congestion control algorithms that are currently widely used in the Internet, including CUBIC, Bottleneck Bandwidth and Round-trip propagation time (BBR), and LEDBAT(++).</t>
        </li>
        <li pn="section-5-2.2">
          <t indent="0" pn="section-5-2.2.1">Interaction between rLEDBAT and Active Queue Management techniques such as Controlled Delay (CoDel); Proportional Integral controller Enhanced (PIE); and Low Latency, Low Loss, and Scalable Throughput (L4S).
</t>
        </li>
        <li pn="section-5-2.3">
          <t indent="0" pn="section-5-2.3.1">How rLEDBAT should resume after a period during which there was no incoming traffic and the information about the rLEDBAT state information is potentially dated.</t>
        </li>
      </ul>
      <section numbered="true" toc="include" removeInRFC="false" pn="section-5.1">
        <name slugifiedName="name-status-of-the-experiment-at">Status of the Experiment at the Time of This Writing</name>
        <t indent="0" pn="section-5.1-1">Currently, the following implementations of rLEDBAT can be used for experimentation:</t>
        <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-5.1-2">
          <li pn="section-5.1-2.1">
            <t indent="0" pn="section-5.1-2.1.1">Windows 11.  rLEDBAT is available in Microsoft's Windows 11 22H2 since October 2023 <xref target="Windows11" format="default" sectionFormat="of" derivedContent="Windows11"/>.</t>
          </li>
          <li pn="section-5.1-2.2">
            <t indent="0" pn="section-5.1-2.2.1">Windows Server 2022.  rLEDBAT is available in Microsoft's Windows Server 2022 since September 2022 <xref target="WindowsServer" format="default" sectionFormat="of" derivedContent="WindowsServer"/>.</t>
          </li>
          <li pn="section-5.1-2.3">
            <t indent="0" pn="section-5.1-2.3.1">Apple.  rLEDBAT is available in macOS and iOS since 2021   <xref target="Apple" format="default" sectionFormat="of" derivedContent="Apple"/>.</t>
          </li>
          <li pn="section-5.1-2.4">
            <t indent="0" pn="section-5.1-2.4.1">Linux implementation, open source, available since 2022 <xref target="rledbat_module" format="default" sectionFormat="of" derivedContent="rledbat_module"/>.</t>
          </li>
          <li pn="section-5.1-2.5">
            <t indent="0" pn="section-5.1-2.5.1">ns3 implementation, open source, available since 2020 <xref target="rLEDBAT-in-ns-3" format="default" sectionFormat="of" derivedContent="rLEDBAT-in-ns-3"/>.</t>
          </li>
        </ul>
        <t indent="0" pn="section-5.1-3">In addition, rLEDBAT has been deployed by Microsoft at wide scale in the following services:
        </t>
        <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-5.1-4">
          <li pn="section-5.1-4.1">
            <t indent="0" pn="section-5.1-4.1.1">BITS (Background Intelligent Transfer Service)</t>
          </li>
          <li pn="section-5.1-4.2">
            <t indent="0" pn="section-5.1-4.2.1">DO (Delivery Optimization) service</t>
          </li>
          <li pn="section-5.1-4.3">
            <t indent="0" pn="section-5.1-4.3.1">Windows update: using DO</t>
          </li>
          <li pn="section-5.1-4.4">
            <t indent="0" pn="section-5.1-4.4.1">Windows Store: using DO</t>
          </li>
          <li pn="section-5.1-4.5">
            <t indent="0" pn="section-5.1-4.5.1">OneDrive</t>
          </li>
          <li pn="section-5.1-4.6">
            <t indent="0" pn="section-5.1-4.6.1">Windows Error Reporting: wermgr.exe; werfault.exe</t>
          </li>
          <li pn="section-5.1-4.7">
            <t indent="0" pn="section-5.1-4.7.1">System Center Configuration Manager (SCCM)</t>
          </li>
          <li pn="section-5.1-4.8">
            <t indent="0" pn="section-5.1-4.8.1">Windows Media Player</t>
          </li>
          <li pn="section-5.1-4.9">
            <t indent="0" pn="section-5.1-4.9.1">Microsoft Office</t>
          </li>
          <li pn="section-5.1-4.10">
            <t indent="0" pn="section-5.1-4.10.1">Xbox (download games): using DO</t>
          </li>
        </ul>
        <t indent="0" pn="section-5.1-5"> Some initial experiments involving rLEDBAT have been reported in <xref target="COMNET3" format="default" sectionFormat="of" derivedContent="COMNET3"/>. Experiments involving the interaction between LEDBAT++ and BBR are presented in <xref target="COMNET2" format="default" sectionFormat="of" derivedContent="COMNET2"/>. An experimental evaluation of the LEDBAT++ algorithm is presented in <xref target="COMNET1" format="default" sectionFormat="of" derivedContent="COMNET1"/>. As LEDBAT++ is one of the less-than-best-effort congestion control algorithms that rLEDBAT relies on, the results regarding how LEDBAT++ interacts with other congestion control algorithms are relevant for the understanding of rLEDBAT as well.</t>
      </section>
    </section>
    <section numbered="true" toc="include" removeInRFC="false" pn="section-6">
      <name slugifiedName="name-security-considerations">Security Considerations</name>
      <t indent="0" pn="section-6-1">Overall, we believe that rLEDBAT does not introduce any new vulnerabilities to existing TCP endpoints, as it relies on existing TCP knobs, notably the receive window and timestamps. </t>
      <t indent="0" pn="section-6-2">Specifically, rLEDBAT uses RCV.WND to modulate the rate of the sender. An attacker wishing to starve a flow can simply reduce the RCV.WND, irrespective of whether rLEDBAT is being used or not.</t>
      <t indent="0" pn="section-6-3"> We can further ask ourselves whether the attacker can use the rLEDBAT mechanisms in place to force the rLEDBAT receiver to reduce the RCV.WND. There are two ways an attacker can do this:</t>
      <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-6-4">
        <li pn="section-6-4.1">One would be to introduce an artificial delay to the packets by either actually delaying the packets or modifying the timestamps. This would cause the rLEDBAT receiver to believe that a queue is building up and reduce the RCV.WND. Note that to do so, an attacker must be on path, so if that is the case, it is probably more direct to simply reduce the RCV.WND.</li>
        <li pn="section-6-4.2">The other option would be for the attacker to make the rLEDBAT receiver believe that a loss has occurred. To do this, it basically needs to retransmit an old packet (to be precise, it needs to transmit a packet with the correct sequence number and the correct port and IP numbers). This means that the attacker can achieve a reduction of incoming traffic to the rLEDBAT receiver not only by modifying the RCV.WND field of the packets originated from the rLEDBAT host but also by injecting packets with the proper sequence number in the other direction. This may slightly expand the attack surface.</li>
      </ul>
    </section>
    <section numbered="true" toc="include" removeInRFC="false" pn="section-7">
      <name slugifiedName="name-iana-considerations">IANA Considerations</name>
      <t indent="0" pn="section-7-1">This document has no IANA actions.</t>
    </section>
  </middle>
  <back>
    <displayreference target="I-D.irtf-iccrg-ledbat-plus-plus" to="LEDBAT++"/>
    <references pn="section-8">
      <name slugifiedName="name-references">References</name>
      <references anchor="sec-normative-references" pn="section-8.1">
        <name slugifiedName="name-normative-references">Normative References</name>
        <reference anchor="RFC2119" target="https://www.rfc-editor.org/info/rfc2119" quoteTitle="true" derivedAnchor="RFC2119">
          <front>
            <title>Key words for use in RFCs to Indicate Requirement Levels</title>
            <author fullname="S. Bradner" initials="S." surname="Bradner"/>
            <date month="March" year="1997"/>
            <abstract>
              <t indent="0">In many standards track documents several words are used to signify the requirements in the specification. These words are often capitalized. This document defines these words as they should be interpreted in IETF documents. This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="14"/>
          <seriesInfo name="RFC" value="2119"/>
          <seriesInfo name="DOI" value="10.17487/RFC2119"/>
        </reference>
        <reference anchor="RFC8174" target="https://www.rfc-editor.org/info/rfc8174" quoteTitle="true" derivedAnchor="RFC8174">
          <front>
            <title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
            <author fullname="B. Leiba" initials="B." surname="Leiba"/>
            <date month="May" year="2017"/>
            <abstract>
              <t indent="0">RFC 2119 specifies common key words that may be used in protocol specifications. This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the defined special meanings.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="14"/>
          <seriesInfo name="RFC" value="8174"/>
          <seriesInfo name="DOI" value="10.17487/RFC8174"/>
        </reference>
      </references>
      <references anchor="sec-informative-references" pn="section-8.2">
        <name slugifiedName="name-informative-references">Informative References</name>
        <reference anchor="Apple" target="https://developer.apple.com/videos/play/wwdc2021/10239/" quoteTitle="true" derivedAnchor="Apple">
          <front>
            <title>Reduce network delays for your app</title>
            <author initials="S" surname="Cheshire" fullname="Stuart Cheshire">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="V" surname="Goel" fullname="Vidhi Goel">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2021"/>
          </front>
          <refcontent>Apple Worldwide Developers Conference (WWDC2021), Video</refcontent>
        </reference>
        <reference anchor="COMNET1" quoteTitle="true" target="https://doi.org/10.1016/j.comnet.2022.109036" derivedAnchor="COMNET1">
          <front>
            <title>An experimental evaluation of LEDBAT++</title>
            <author initials="M" surname="Bagnulo" fullname="Marcelo Bagnulo">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="A" surname="García-Martínez" fullname="Alberto García-Martínez">
              <organization showOnFrontPage="true"/>
            </author>
            <date month="July" year="2022"/>
          </front>
          <refcontent>Computer Networks, vol. 212</refcontent>
          <seriesInfo name="DOI" value="10.1016/j.comnet.2022.109036"/>
        </reference>
        <reference anchor="COMNET2" quoteTitle="true" target="https://doi.org/10.1016/j.comnet.2022.109460" derivedAnchor="COMNET2">
          <front>
            <title>When less is more: BBR versus LEDBAT++</title>
            <author initials="M" surname="Bagnulo" fullname="Marcelo Bagnulo">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="A" surname="García-Martínez" fullname="Alberto García-Martínez">
              <organization showOnFrontPage="true"/>
            </author>
            <date month="December" year="2022"/>
          </front>
          <refcontent>Computer Networks, vol. 219</refcontent>
          <seriesInfo name="DOI" value="10.1016/j.comnet.2022.109460"/>
        </reference>
        <reference anchor="COMNET3" quoteTitle="true" target="https://doi.org/10.1016/j.comnet.2023.109841" derivedAnchor="COMNET3">
          <front>
            <title>Design, implementation and validation of a receiver-driven less-than-best-effort transport</title>
            <author initials="M" surname="Bagnulo" fullname="Marcelo Bagnulo">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="A" surname="García-Martínez" fullname="Alberto García-Martínez">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="A.M." surname="Mandalari" fullname="Anna Maria Mandalari">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="P" surname="Balasubramanian" fullname="Praveen Balasubramanian">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="D" surname="Havey" fullname="Daniel Havey">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="G" surname="Montenegro" fullname="Gabriel Montenegro">
              <organization showOnFrontPage="true"/>
            </author>
            <date month="September" year="2023"/>
          </front>
          <refcontent>Computer Networks, vol. 233</refcontent>
          <seriesInfo name="DOI" value="10.1016/j.comnet.2023.109841"/>
        </reference>
        <reference anchor="I-D.irtf-iccrg-ledbat-plus-plus" target="https://datatracker.ietf.org/doc/html/draft-irtf-iccrg-ledbat-plus-plus-03" quoteTitle="true" derivedAnchor="LEDBAT++">
          <front>
            <title>LEDBAT++: Congestion Control for Background Traffic</title>
            <author fullname="Praveen Balasubramanian" initials="P." surname="Balasubramanian">
              <organization showOnFrontPage="true">Confluent</organization>
            </author>
            <author fullname="Osman Ertugay" initials="O." surname="Ertugay">
              <organization showOnFrontPage="true">Microsoft</organization>
            </author>
            <author fullname="Daniel Havey" initials="D." surname="Havey">
              <organization showOnFrontPage="true">Microsoft</organization>
            </author>
            <author fullname="Marcelo Bagnulo" initials="M." surname="Bagnulo">
              <organization showOnFrontPage="true">Universidad Carlos III de Madrid</organization>
            </author>
            <date day="9" month="September" year="2025"/>
            <abstract>
              <t indent="0">This memo describes LEDBAT++, a set of enhancements to the LEDBAT (Low Extra Delay Background Transport) congestion control algorithm for background traffic. The LEDBAT congestion control algorithm has several shortcomings that prevent it from working effectively in practice. LEDBAT++ extends LEDBAT by adding a set of improvements, including reduced congestion window gain, modified slow-start, multiplicative decrease and periodic slowdowns. This set of improvement mitigates the known issues with the LEDBAT algorithm, such as latency drift, latecomer advantage and inter-LEDBAT fairness. LEDBAT++ has been implemented as a TCP congestion control algorithm in the Windows operating system. LEDBAT++ has been deployed in production at scale on a variety of networks and been experimentally verified to achieve the original stated goals of LEDBAT. This document is a product of the Internet Congestion Control Research Group (ICCRG) of the Internet Research Task Force (IRTF).</t>
            </abstract>
          </front>
          <seriesInfo name="Internet-Draft" value="draft-irtf-iccrg-ledbat-plus-plus-03"/>
          <refcontent>Work in Progress</refcontent>
        </reference>
        <reference anchor="RFC5681" target="https://www.rfc-editor.org/info/rfc5681" quoteTitle="true" derivedAnchor="RFC5681">
          <front>
            <title>TCP Congestion Control</title>
            <author fullname="M. Allman" initials="M." surname="Allman"/>
            <author fullname="V. Paxson" initials="V." surname="Paxson"/>
            <author fullname="E. Blanton" initials="E." surname="Blanton"/>
            <date month="September" year="2009"/>
            <abstract>
              <t indent="0">This document defines TCP's four intertwined congestion control algorithms: slow start, congestion avoidance, fast retransmit, and fast recovery. In addition, the document specifies how TCP should begin transmission after a relatively long idle period, as well as discussing various acknowledgment generation methods. This document obsoletes RFC 2581. [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="5681"/>
          <seriesInfo name="DOI" value="10.17487/RFC5681"/>
        </reference>
        <reference anchor="RFC6582" target="https://www.rfc-editor.org/info/rfc6582" quoteTitle="true" derivedAnchor="RFC6582">
          <front>
            <title>The NewReno Modification to TCP's Fast Recovery Algorithm</title>
            <author fullname="T. Henderson" initials="T." surname="Henderson"/>
            <author fullname="S. Floyd" initials="S." surname="Floyd"/>
            <author fullname="A. Gurtov" initials="A." surname="Gurtov"/>
            <author fullname="Y. Nishida" initials="Y." surname="Nishida"/>
            <date month="April" year="2012"/>
            <abstract>
              <t indent="0">RFC 5681 documents the following four intertwined TCP congestion control algorithms: slow start, congestion avoidance, fast retransmit, and fast recovery. RFC 5681 explicitly allows certain modifications of these algorithms, including modifications that use the TCP Selective Acknowledgment (SACK) option (RFC 2883), and modifications that respond to "partial acknowledgments" (ACKs that cover new data, but not all the data outstanding when loss was detected) in the absence of SACK. This document describes a specific algorithm for responding to partial acknowledgments, referred to as "NewReno". This response to partial acknowledgments was first proposed by Janey Hoe. This document obsoletes RFC 3782. [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6582"/>
          <seriesInfo name="DOI" value="10.17487/RFC6582"/>
        </reference>
        <reference anchor="RFC6817" target="https://www.rfc-editor.org/info/rfc6817" quoteTitle="true" derivedAnchor="RFC6817">
          <front>
            <title>Low Extra Delay Background Transport (LEDBAT)</title>
            <author fullname="S. Shalunov" initials="S." surname="Shalunov"/>
            <author fullname="G. Hazel" initials="G." surname="Hazel"/>
            <author fullname="J. Iyengar" initials="J." surname="Iyengar"/>
            <author fullname="M. Kuehlewind" initials="M." surname="Kuehlewind"/>
            <date month="December" year="2012"/>
            <abstract>
              <t indent="0">Low Extra Delay Background Transport (LEDBAT) is an experimental delay-based congestion control algorithm that seeks to utilize the available bandwidth on an end-to-end path while limiting the consequent increase in queueing delay on that path. LEDBAT uses changes in one-way delay measurements to limit congestion that the flow itself induces in the network. LEDBAT is designed for use by background bulk-transfer applications to be no more aggressive than standard TCP congestion control (as specified in RFC 5681) and to yield in the presence of competing flows, thus limiting interference with the network performance of competing flows. This document defines an Experimental Protocol for the Internet community.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6817"/>
          <seriesInfo name="DOI" value="10.17487/RFC6817"/>
        </reference>
        <reference anchor="RFC7323" target="https://www.rfc-editor.org/info/rfc7323" quoteTitle="true" derivedAnchor="RFC7323">
          <front>
            <title>TCP Extensions for High Performance</title>
            <author fullname="D. Borman" initials="D." surname="Borman"/>
            <author fullname="B. Braden" initials="B." surname="Braden"/>
            <author fullname="V. Jacobson" initials="V." surname="Jacobson"/>
            <author fullname="R. Scheffenegger" initials="R." role="editor" surname="Scheffenegger"/>
            <date month="September" year="2014"/>
            <abstract>
              <t indent="0">This document specifies a set of TCP extensions to improve performance over paths with a large bandwidth * delay product and to provide reliable operation over very high-speed paths. It defines the TCP Window Scale (WS) option and the TCP Timestamps (TS) option and their semantics. The Window Scale option is used to support larger receive windows, while the Timestamps option can be used for at least two distinct mechanisms, Protection Against Wrapped Sequences (PAWS) and Round-Trip Time Measurement (RTTM), that are also described herein.</t>
              <t indent="0">This document obsoletes RFC 1323 and describes changes from it.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7323"/>
          <seriesInfo name="DOI" value="10.17487/RFC7323"/>
        </reference>
        <reference anchor="RFC9293" target="https://www.rfc-editor.org/info/rfc9293" quoteTitle="true" derivedAnchor="RFC9293">
          <front>
            <title>Transmission Control Protocol (TCP)</title>
            <author fullname="W. Eddy" initials="W." role="editor" surname="Eddy"/>
            <date month="August" year="2022"/>
            <abstract>
              <t indent="0">This document specifies the Transmission Control Protocol (TCP). TCP is an important transport-layer protocol in the Internet protocol stack, and it has continuously evolved over decades of use and growth of the Internet. Over this time, a number of changes have been made to TCP as it was specified in RFC 793, though these have only been documented in a piecemeal fashion. This document collects and brings those changes together with the protocol specification from RFC 793. This document obsoletes RFC 793, as well as RFCs 879, 2873, 6093, 6429, 6528, and 6691 that updated parts of RFC 793. It updates RFCs 1011 and 1122, and it should be considered as a replacement for the portions of those documents dealing with TCP requirements. It also updates RFC 5961 by adding a small clarification in reset handling while in the SYN-RECEIVED state. The TCP header control bits from RFC 793 have also been updated based on RFC 3168.</t>
            </abstract>
          </front>
          <seriesInfo name="STD" value="7"/>
          <seriesInfo name="RFC" value="9293"/>
          <seriesInfo name="DOI" value="10.17487/RFC9293"/>
        </reference>
        <reference anchor="RFC9438" target="https://www.rfc-editor.org/info/rfc9438" quoteTitle="true" derivedAnchor="RFC9438">
          <front>
            <title>CUBIC for Fast and Long-Distance Networks</title>
            <author fullname="L. Xu" initials="L." surname="Xu"/>
            <author fullname="S. Ha" initials="S." surname="Ha"/>
            <author fullname="I. Rhee" initials="I." surname="Rhee"/>
            <author fullname="V. Goel" initials="V." surname="Goel"/>
            <author fullname="L. Eggert" initials="L." role="editor" surname="Eggert"/>
            <date month="August" year="2023"/>
            <abstract>
              <t indent="0">CUBIC is a standard TCP congestion control algorithm that uses a cubic function instead of a linear congestion window increase function to improve scalability and stability over fast and long-distance networks. CUBIC has been adopted as the default TCP congestion control algorithm by the Linux, Windows, and Apple stacks.</t>
              <t indent="0">This document updates the specification of CUBIC to include algorithmic improvements based on these implementations and recent academic work. Based on the extensive deployment experience with CUBIC, this document also moves the specification to the Standards Track and obsoletes RFC 8312. This document also updates RFC 5681, to allow for CUBIC's occasionally more aggressive sending behavior.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="9438"/>
          <seriesInfo name="DOI" value="10.17487/RFC9438"/>
        </reference>
        <reference anchor="rLEDBAT-in-ns-3" target="https://github.com/manas11/implementation-of-rLEDBAT-in-ns-3" quoteTitle="true" derivedAnchor="rLEDBAT-in-ns-3">
          <front>
            <title>Implementation-of-rLEDBAT-in-ns-3</title>
            <author/>
            <date month="June" day="24" year="2020"/>
          </front>
          <refcontent>commit 2ab34ad</refcontent>
        </reference>
        <reference anchor="rledbat_module" target="https://github.com/net-research/rledbat_module" quoteTitle="true" derivedAnchor="rledbat_module">
          <front>
            <title>rledbat_module</title>
            <author/>
            <date month="September" day="9" year="2022"/>
          </front>
          <refcontent>commit d82ff20</refcontent>
        </reference>
        <reference anchor="Windows11" target="https://learn.microsoft.com/en-us/windows/deployment/do/whats-new-do" quoteTitle="true" derivedAnchor="Windows11">
          <front>
            <title>What's new in Delivery Optimization</title>
            <author>
              <organization showOnFrontPage="true">Microsoft</organization>
            </author>
            <date month="October" year="2024"/>
          </front>
          <refcontent>Microsoft Windows Documentation</refcontent>
        </reference>
        <reference anchor="WindowsServer" target="https://techcommunity.microsoft.com/t5/networking-blog/ledbat-background-data-transfer-for-windows/ba-p/3639278" quoteTitle="true" derivedAnchor="WindowsServer">
          <front>
            <title>LEDBAT Background Data Transfer for Windows</title>
            <author initials="D" surname="Havey" fullname="Daniel">
              <organization showOnFrontPage="true"/>
            </author>
            <date month="September" year="2022"/>
          </front>
          <refcontent>Microsoft Networking Blog</refcontent>
        </reference>
      </references>
    </references>
    <section numbered="true" toc="include" removeInRFC="false" pn="section-appendix.a">
      <name slugifiedName="name-rledbat-pseudocode">rLEDBAT Pseudocode</name>
      <t indent="0" pn="section-appendix.a-1">In this section, we describe how to integrate the proposed rLEDBAT mechanisms and  an LBE delay-based congestion control algorithm such as LEDBAT or LEDBAT++.  We describe the integrated  algorithm as two procedures: one that is executed when a packet is received by a rLEDBAT-enabled endpoint (<xref target="fig2" format="default" sectionFormat="of" derivedContent="Figure 2"/>) and another that is executed when the rLEDBAT-enabled endpoint sends a packet (<xref target="fig3" format="default" sectionFormat="of" derivedContent="Figure 3"/>). At the beginning, RLWND is set to its maximum value, so that the sending rate of the sender is governed by the flow control algorithm of the receiver and the TCP slow start mechanism of the sender, and the ackedBytes variable is set to 0. </t>
      <t indent="0" pn="section-appendix.a-2">We assume that the LBE congestion control algorithm defines a WindowIncrease() function and a WindowDecrease() function. For example, in the case of LEDBAT++, the WindowIncrease() function is an additive increase, while the WindowDecrease() function is a multiplicative decrease. In the case of the WindowIncrease() function, we assume that it takes as input the current window size and the number of bytes that were acknowledged since the last window update (ackedBytes) and returns as output the updated window size. In the case of the WindowDecrease() function, it takes as input the current window size and returns the updated window size. </t>
      <t indent="0" pn="section-appendix.a-3">The data structures used in the algorithms are as follows. The sendList is a list that contains  the TSval and the local send time of each packet sent by the rLEDBAT-enabled endpoint. The TSecr field of the packets received by the rLEDBAT-enabled endpoint is matched with the sendList to compute the RTT.</t>
      <t indent="0" pn="section-appendix.a-4">The RTT values computed for each received packet are stored in the RTTlist, which also contains the received TSecr (to avoid using multiple packets with the same TSecr for RTT calculations, only the first packet received for a given TSecr is used to compute the RTT). It also contains the local time at which the packet was received, to allow selecting the RTTs measured in a given period (e.g., in the last 10 minutes). RTTlist is initialized with all its values to its maximum.</t>
      <figure anchor="fig2" align="left" suppress-title="false" pn="figure-2">
        <name slugifiedName="name-procedure-executed-when-a-p">Procedure Executed When a Packet Is Received</name>
        <sourcecode type="pseudocode" markers="false" pn="section-appendix.a-5.1">
procedure receivePacket()
  //Looks for first sent packet with same TSval as TSecr, and
  //returns time difference
  receivedRTT = computeRTT(sendList, receivedTSecr, receivedTime)

  //Inserts minimum value for a given receivedTSecr
  //Note that many received packets may contain same receivedTSecr
  insertRTT (RTTlist, receivedRTT, receivedTSecr, receivedTime)

  filteredRTT = minLastKMeasures(RTTlist, K=4)
  baseRTT = minLastNSeconds(RTTlist, N=180)
  qd = filteredRTT - baseRTT

  //ackedBytes is the number of bytes that can be used to reduce
  //the receive window - without shrinking it - if necessary
  ackedBytes = ackedBytes + receiveBytes

  if retransmittedPacketDetected then
        RLWND = DecreaseWindow(RLWND)  //Only once per RTT
  end if
  if qd &lt; T then
        RLWND = IncreaseWindow(RLWND, ackedBytes)
  else
        RLWND = DecreaseWindow(RLWND)
  end if
end procedure
</sourcecode>
      </figure>
      <figure anchor="fig3" align="left" suppress-title="false" pn="figure-3">
        <name slugifiedName="name-procedure-executed-when-a-pa">Procedure Executed When a Packet Is Sent</name>
        <sourcecode type="pseudocode" markers="false" pn="section-appendix.a-6.1">
procedure SENDPACKET
  if (RLWND &gt; RLWNDPrevious) or (RLWND - RLWNDPrevious &lt; ackedBytes)
  then
        RLWNDPrevious = RLWND
  else
        RLWNDPrevious = RLWND - ackedBytes
  end if
  ackedBytes = 0
  RLWNDPrevious = RLWND

  //Compute the RLWND to include in the packet
  RLWND = min(RLWND, fcwnd)
end procedure
</sourcecode>
      </figure>
    </section>
    <section numbered="false" toc="include" removeInRFC="false" pn="section-appendix.b">
      <name slugifiedName="name-acknowledgments">Acknowledgments</name>
      <t indent="0" pn="section-appendix.b-1">This work was supported by the EU through the StandICT projects RXQ, CCI, and CEL6; the NGI Pointer RIM project; and the H2020 5G-RANGE project; and by the Spanish Ministry of Economy and Competitiveness through the 5G-City project (TEC2016-76795-C6-3-R).</t>
      <t indent="0" pn="section-appendix.b-2">We would like to thank ICCRG chairs <contact fullname="Reese Enghardt"/> and <contact fullname="Vidhi Goel"/> for their support on this work. We would also like to thank <contact fullname="Daniel Havey"/> for his help. We would like to thank <contact fullname="Colin Perkins"/>, <contact fullname="Mirja Kühlewind"/>, and <contact fullname="Vidhi Goel"/> for their reviews and comments on earlier draft versions of this document.</t>
    </section>
    <section anchor="authors-addresses" numbered="false" removeInRFC="false" toc="include" pn="section-appendix.c">
      <name slugifiedName="name-authors-addresses">Authors' Addresses</name>
      <author fullname="Marcelo Bagnulo" initials="M." surname="Bagnulo">
        <organization showOnFrontPage="true">Universidad Carlos III de Madrid</organization>
        <address>
          <email>marcelo@it.uc3m.es</email>
        </address>
      </author>
      <author fullname="Alberto García-Martínez" initials="A." surname="García-Martínez">
        <organization showOnFrontPage="true">Universidad Carlos III de Madrid</organization>
        <address>
          <email>alberto@it.uc3m.es</email>
        </address>
      </author>
      <author fullname="Gabriel Montenegro" initials="G." surname="Montenegro">
        <address>
          <email>g.e.montenegro@hotmail.com</email>
        </address>
      </author>
      <author fullname="Praveen Balasubramanian" initials="P." surname="Balasubramanian">
        <organization showOnFrontPage="true">Confluent</organization>
        <address>
          <email>pravb.ietf@gmail.com</email>
        </address>
      </author>
    </section>
  </back>
</rfc>
