<?xml version='1.0' encoding='utf-8'?>
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" version="3" ipr="trust200902" docName="draft-ietf-radext-tls-psk-12" number="9813" category="bcp" consensus="true" submissionType="IETF" tocInclude="true" sortRefs="true" symRefs="true" xml:lang="en" updates="" obsoletes="" prepTime="2025-07-11T14:34:08" indexInclude="true" scripts="Common,Latin" tocDepth="3">
  <link href="https://datatracker.ietf.org/doc/draft-ietf-radext-tls-psk-12" rel="prev"/>
  <link href="https://dx.doi.org/10.17487/rfc9813" rel="alternate"/>
  <link href="urn:issn:2070-1721" rel="alternate"/>
  <front>
    <title abbrev="RADIUS and TLS-PSK">Operational Considerations for Using TLS Pre-Shared Keys (TLS-PSKs) with RADIUS</title>
    <seriesInfo name="RFC" value="9813" stream="IETF"/>
    <seriesInfo name="BCP" value="243" stream="IETF"/>
    <author initials="A." surname="DeKok" fullname="Alan DeKok">
      <organization showOnFrontPage="true">InkBridge Networks</organization>
      <address>
        <email>alan.dekok@inkbridge.io</email>
      </address>
    </author>
    <date month="07" year="2025"/>
    <area>SEC</area>
    <workgroup>radext</workgroup>
    <keyword>example</keyword>
    <abstract pn="section-abstract">
      <t indent="0" pn="section-abstract-1">This document provides implementation and operational considerations
      for using TLS Pre-Shared Keys (TLS-PSKs) with RADIUS/TLS (RFC 6614) and RADIUS/DTLS (RFC 7360).
      The purpose of the document is to help smooth the operational transition
      from the use of RADIUS/UDP to RADIUS/TLS.</t>
    </abstract>
    <boilerplate>
      <section anchor="status-of-memo" numbered="false" removeInRFC="false" toc="exclude" pn="section-boilerplate.1">
        <name slugifiedName="name-status-of-this-memo">Status of This Memo</name>
        <t indent="0" pn="section-boilerplate.1-1">
            This memo documents an Internet Best Current Practice.
        </t>
        <t indent="0" pn="section-boilerplate.1-2">
            This document is a product of the Internet Engineering Task Force
            (IETF).  It represents the consensus of the IETF community.  It has
            received public review and has been approved for publication by
            the Internet Engineering Steering Group (IESG).  Further information
            on BCPs is available in Section 2 of RFC 7841.
        </t>
        <t indent="0" pn="section-boilerplate.1-3">
            Information about the current status of this document, any
            errata, and how to provide feedback on it may be obtained at
            <eref target="https://www.rfc-editor.org/info/rfc9813" brackets="none"/>.
        </t>
      </section>
      <section anchor="copyright" numbered="false" removeInRFC="false" toc="exclude" pn="section-boilerplate.2">
        <name slugifiedName="name-copyright-notice">Copyright Notice</name>
        <t indent="0" pn="section-boilerplate.2-1">
            Copyright (c) 2025 IETF Trust and the persons identified as the
            document authors. All rights reserved.
        </t>
        <t indent="0" pn="section-boilerplate.2-2">
            This document is subject to BCP 78 and the IETF Trust's Legal
            Provisions Relating to IETF Documents
            (<eref target="https://trustee.ietf.org/license-info" brackets="none"/>) in effect on the date of
            publication of this document. Please review these documents
            carefully, as they describe your rights and restrictions with
            respect to this document. Code Components extracted from this
            document must include Revised BSD License text as described in
            Section 4.e of the Trust Legal Provisions and are provided without
            warranty as described in the Revised BSD License.
        </t>
      </section>
    </boilerplate>
    <toc>
      <section anchor="toc" numbered="false" removeInRFC="false" toc="exclude" pn="section-toc.1">
        <name slugifiedName="name-table-of-contents">Table of Contents</name>
        <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1">
          <li pn="section-toc.1-1.1">
            <t indent="0" keepWithNext="true" pn="section-toc.1-1.1.1"><xref derivedContent="1" format="counter" sectionFormat="of" target="section-1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-introduction">Introduction</xref></t>
          </li>
          <li pn="section-toc.1-1.2">
            <t indent="0" keepWithNext="true" pn="section-toc.1-1.2.1"><xref derivedContent="2" format="counter" sectionFormat="of" target="section-2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-terminology">Terminology</xref></t>
          </li>
          <li pn="section-toc.1-1.3">
            <t indent="0" keepWithNext="true" pn="section-toc.1-1.3.1"><xref derivedContent="3" format="counter" sectionFormat="of" target="section-3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-justification-of-psk">Justification of PSK</xref></t>
          </li>
          <li pn="section-toc.1-1.4">
            <t indent="0" pn="section-toc.1-1.4.1"><xref derivedContent="4" format="counter" sectionFormat="of" target="section-4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-general-discussion-of-psks-">General Discussion of PSKs and PSK Identities</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.4.2">
              <li pn="section-toc.1-1.4.2.1">
                <t indent="0" pn="section-toc.1-1.4.2.1.1"><xref derivedContent="4.1" format="counter" sectionFormat="of" target="section-4.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-guidance-for-psks">Guidance for PSKs</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.4.2.1.2">
                  <li pn="section-toc.1-1.4.2.1.2.1">
                    <t indent="0" pn="section-toc.1-1.4.2.1.2.1.1"><xref derivedContent="4.1.1" format="counter" sectionFormat="of" target="section-4.1.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-psk-requirements">PSK Requirements</xref></t>
                  </li>
                  <li pn="section-toc.1-1.4.2.1.2.2">
                    <t indent="0" pn="section-toc.1-1.4.2.1.2.2.1"><xref derivedContent="4.1.2" format="counter" sectionFormat="of" target="section-4.1.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-usability-guidance">Usability Guidance</xref></t>
                  </li>
                  <li pn="section-toc.1-1.4.2.1.2.3">
                    <t indent="0" pn="section-toc.1-1.4.2.1.2.3.1"><xref derivedContent="4.1.3" format="counter" sectionFormat="of" target="section-4.1.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-interaction-between-psks-an">Interaction Between PSKs and RADIUS Shared Secrets</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.4.2.2">
                <t indent="0" pn="section-toc.1-1.4.2.2.1"><xref derivedContent="4.2" format="counter" sectionFormat="of" target="section-4.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-psk-identities">PSK Identities</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.4.2.2.2">
                  <li pn="section-toc.1-1.4.2.2.2.1">
                    <t indent="0" pn="section-toc.1-1.4.2.2.2.1.1"><xref derivedContent="4.2.1" format="counter" sectionFormat="of" target="section-4.2.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-security-of-psk-identities">Security of PSK Identities</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.4.2.3">
                <t indent="0" pn="section-toc.1-1.4.2.3.1"><xref derivedContent="4.3" format="counter" sectionFormat="of" target="section-4.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-psk-and-psk-identity-sharin">PSK and PSK Identity Sharing</xref></t>
              </li>
              <li pn="section-toc.1-1.4.2.4">
                <t indent="0" pn="section-toc.1-1.4.2.4.1"><xref derivedContent="4.4" format="counter" sectionFormat="of" target="section-4.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-psk-lifetimes">PSK Lifetimes</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.5">
            <t indent="0" pn="section-toc.1-1.5.1"><xref derivedContent="5" format="counter" sectionFormat="of" target="section-5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-guidance-for-radius-clients">Guidance for RADIUS Clients</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.5.2">
              <li pn="section-toc.1-1.5.2.1">
                <t indent="0" pn="section-toc.1-1.5.2.1.1"><xref derivedContent="5.1" format="counter" sectionFormat="of" target="section-5.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-psk-identities-2">PSK Identities</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.5.2.1.2">
                  <li pn="section-toc.1-1.5.2.1.2.1">
                    <t indent="0" pn="section-toc.1-1.5.2.1.2.1.1"><xref derivedContent="5.1.1" format="counter" sectionFormat="of" target="section-5.1.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-psk-identity-requirements">PSK Identity Requirements</xref></t>
                  </li>
                  <li pn="section-toc.1-1.5.2.1.2.2">
                    <t indent="0" pn="section-toc.1-1.5.2.1.2.2.1"><xref derivedContent="5.1.2" format="counter" sectionFormat="of" target="section-5.1.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-usability-guidance-2">Usability Guidance</xref></t>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.6">
            <t indent="0" pn="section-toc.1-1.6.1"><xref derivedContent="6" format="counter" sectionFormat="of" target="section-6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-guidance-for-radius-servers">Guidance for RADIUS Servers</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.6.2">
              <li pn="section-toc.1-1.6.2.1">
                <t indent="0" pn="section-toc.1-1.6.2.1.1"><xref derivedContent="6.1" format="counter" sectionFormat="of" target="section-6.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-current-practices">Current Practices</xref></t>
              </li>
              <li pn="section-toc.1-1.6.2.2">
                <t indent="0" pn="section-toc.1-1.6.2.2.1"><xref derivedContent="6.2" format="counter" sectionFormat="of" target="section-6.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-practices-for-tls-psk">Practices for TLS-PSK</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.6.2.2.2">
                  <li pn="section-toc.1-1.6.2.2.2.1">
                    <t indent="0" pn="section-toc.1-1.6.2.2.2.1.1"><xref derivedContent="6.2.1" format="counter" sectionFormat="of" target="section-6.2.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-ip-filtering">IP Filtering</xref></t>
                  </li>
                  <li pn="section-toc.1-1.6.2.2.2.2">
                    <t indent="0" pn="section-toc.1-1.6.2.2.2.2.1"><xref derivedContent="6.2.2" format="counter" sectionFormat="of" target="section-6.2.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-psk-authentication">PSK Authentication</xref></t>
                  </li>
                  <li pn="section-toc.1-1.6.2.2.2.3">
                    <t indent="0" pn="section-toc.1-1.6.2.2.2.3.1"><xref derivedContent="6.2.3" format="counter" sectionFormat="of" target="section-6.2.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-resumption">Resumption</xref></t>
                  </li>
                  <li pn="section-toc.1-1.6.2.2.2.4">
                    <t indent="0" pn="section-toc.1-1.6.2.2.2.4.1"><xref derivedContent="6.2.4" format="counter" sectionFormat="of" target="section-6.2.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-interaction-with-other-tls-">Interaction with Other TLS Authentication Methods</xref></t>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.7">
            <t indent="0" pn="section-toc.1-1.7.1"><xref derivedContent="7" format="counter" sectionFormat="of" target="section-7"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-privacy-considerations">Privacy Considerations</xref></t>
          </li>
          <li pn="section-toc.1-1.8">
            <t indent="0" pn="section-toc.1-1.8.1"><xref derivedContent="8" format="counter" sectionFormat="of" target="section-8"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-security-considerations">Security Considerations</xref></t>
          </li>
          <li pn="section-toc.1-1.9">
            <t indent="0" pn="section-toc.1-1.9.1"><xref derivedContent="9" format="counter" sectionFormat="of" target="section-9"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-iana-considerations">IANA Considerations</xref></t>
          </li>
          <li pn="section-toc.1-1.10">
            <t indent="0" pn="section-toc.1-1.10.1"><xref derivedContent="10" format="counter" sectionFormat="of" target="section-10"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-references">References</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.10.2">
              <li pn="section-toc.1-1.10.2.1">
                <t indent="0" pn="section-toc.1-1.10.2.1.1"><xref derivedContent="10.1" format="counter" sectionFormat="of" target="section-10.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-normative-references">Normative References</xref></t>
              </li>
              <li pn="section-toc.1-1.10.2.2">
                <t indent="0" pn="section-toc.1-1.10.2.2.1"><xref derivedContent="10.2" format="counter" sectionFormat="of" target="section-10.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-informative-references">Informative References</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.11">
            <t indent="0" pn="section-toc.1-1.11.1"><xref derivedContent="" format="none" sectionFormat="of" target="section-appendix.a"/><xref derivedContent="" format="title" sectionFormat="of" target="name-acknowledgments">Acknowledgments</xref></t>
          </li>
          <li pn="section-toc.1-1.12">
            <t indent="0" pn="section-toc.1-1.12.1"><xref derivedContent="" format="none" sectionFormat="of" target="section-appendix.b"/><xref derivedContent="" format="title" sectionFormat="of" target="name-authors-address">Author's Address</xref></t>
          </li>
        </ul>
      </section>
    </toc>
  </front>
  <middle>
    <section anchor="introduction" numbered="true" removeInRFC="false" toc="include" pn="section-1">
      <name slugifiedName="name-introduction">Introduction</name>
      <t indent="0" pn="section-1-1">The previous specifications "Transport Layer Security (TLS)
      Encryption for RADIUS" <xref target="RFC6614" format="default" sectionFormat="of" derivedContent="RFC6614"/> and "Datagram Transport
      Layer Security (DTLS) as a Transport Layer for RADIUS" <xref target="RFC7360" format="default" sectionFormat="of" derivedContent="RFC7360"/> defined how (D)TLS can be used as a transport
      protocol for RADIUS.  However, those documents do not provide guidance
      for using TLS Pre-Shared Keys (TLS-PSKs) with RADIUS.  This document provides that missing
      guidance, and gives implementation and operational considerations.</t>
      <t indent="0" pn="section-1-2">To clearly distinguish the various secrets and keys, this document
      uses "shared secret" to mean "RADIUS shared secret", and "Pre-Shared Key
      (PSK)" to mean "secret keys that are used with TLS-PSK".</t>
      <t indent="0" pn="section-1-3">The purpose of the document is to help smooth the operational
      transition from the use of the insecure RADIUS/UDP to the use of the
      much more secure RADIUS/TLS.  While using PSKs is often less preferable
      to using public or private keys, the operational model of PSKs follows
      the legacy RADIUS "shared secret" model.  As such, it can be easier for
      implementers and operators to transition to TLS when that transition is
      offered as a series of small changes.</t>
      <t indent="0" pn="section-1-4">TLS-PSK is intended to be used in networks where the
      addresses of clients and servers are known, as with RADIUS/UDP.  This
      situation is similar to the use case of RADIUS/UDP with shared secrets.
      TLS-PSK is not suitable for situations where clients dynamically
      discover servers, as there is no way for the client to dynamically
      determine which PSK should be used with a new server (or vice versa).
      In contrast, dynamic discovery <xref target="RFC7585" format="default" sectionFormat="of" derivedContent="RFC7585"/> allows for
      a client or server to authenticate a previously unknown server or client,
      as the parties can be issued a certificate by a known Certification
      Authority (CA).</t>
      <t indent="0" pn="section-1-5">TLS-PSKs have the same issue of symmetric information between client
      and server: both parties know the secret key.  A client could, in
      theory, pretend to be a server.  In contrast, certificates are
      asymmetric, where it is impossible for the parties to assume the other's
      identity.  Further discussion of this topic is contained in <xref target="sharing" format="default" sectionFormat="of" derivedContent="Section 4.3"/>.</t>
      <t indent="0" pn="section-1-6">Unless it is explicitly called out that a recommendation applies to
      TLS or DTLS alone, each recommendation applies to both TLS and
      DTLS.</t>
    </section>
    <section anchor="terminology" numbered="true" removeInRFC="false" toc="include" pn="section-2">
      <name slugifiedName="name-terminology">Terminology</name>
      <t indent="0" pn="section-2-1">
    The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>",
    "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>", "<bcp14>SHALL NOT</bcp14>",
    "<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD NOT</bcp14>",
    "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>",
    "<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this document are to be
    interpreted as described in BCP 14 <xref target="RFC2119" format="default" sectionFormat="of" derivedContent="RFC2119"/> <xref target="RFC8174" format="default" sectionFormat="of" derivedContent="RFC8174"/> when, and only when, they appear in all capitals, as
    shown here.
      </t>
      <dl spacing="normal" newline="true" indent="3" pn="section-2-2">
        <dt pn="section-2-2.1">External PSK</dt>
        <dd pn="section-2-2.2">A PSK (along with a related PSK Identity)
          that is administratively configured.  That is, one that is
          external to TLS and is not created by the TLS subsystem.</dd>
        <dt pn="section-2-2.3">Resumption PSK</dt>
        <dd pn="section-2-2.4">A PSK (along with a related PSK Identity)
          that is created by the TLS subsystem and/or application, for use
          with resumption.</dd>
      </dl>
    </section>
    <section anchor="justification-of-psk" numbered="true" removeInRFC="false" toc="include" pn="section-3">
      <name slugifiedName="name-justification-of-psk">Justification of PSK</name>
      <t indent="0" pn="section-3-1">TLS deployments usually rely on certificates in most common
      uses. However, we recognize that it may be difficult to fully upgrade
      client implementations to allow for certificates to be used with
      RADIUS/TLS and RADIUS/DTLS.  These upgrades involve not only
      implementing TLS, but can also require significant changes to
      administration interfaces and application programming interfaces (APIs)
      in order to fully support certificates.</t>
      <t indent="0" pn="section-3-2">For example, unlike shared secrets, certificates expire.  This
      expiration means that a working system using TLS can suddenly stop
      working.  Managing this expiration can require additional notification
      APIs on RADIUS clients and servers that were previously not required
      when shared secrets were used.</t>
      <t indent="0" pn="section-3-3">Certificates also require the use of certification authorities (CAs)
      and chains of certificates.  RADIUS implementations using TLS therefore
      have to track not just a small shared secret, but also potentially many
      large certificates.  The use of TLS-PSK can therefore provide a simpler
      upgrade path for implementations to transition from RADIUS shared
      secrets to TLS.</t>
      <t indent="0" pn="section-3-4">In terms of ongoing maintenance, it is generally simpler to maintain
      servers than clients.  For one, there are many fewer servers than
      clients.  Servers are also typically less resource constrained, and
      often run on general-purpose operating systems, where maintenance can be
      automated using widely available tools.</t>
      <t indent="0" pn="section-3-5">In contrast, clients are often numerous, resource constrained, and
      likely to be closed or proprietary systems with limited interfaces.  As
      a result, it can be difficult to update these clients when a root CA
      expires.  The use of TLS-PSK in such an environment may therefore offer
      management efficiencies.</t>
    </section>
    <section anchor="general-discussion-of-psks-and-psk-identities" numbered="true" removeInRFC="false" toc="include" pn="section-4">
      <name slugifiedName="name-general-discussion-of-psks-">General Discussion of PSKs and PSK Identities</name>
      <t indent="0" pn="section-4-1">Before we define any RADIUS-specific use of PSKs, we must first
      review the current standards for PSKs, and give general advice on PSKs
      and PSK Identities.</t>
      <t indent="0" pn="section-4-2">The requirements in this section apply to both client and server
      implementations that use TLS-PSK.  Client-specific and server-specific
      issues are discussed in more detail later in this document.</t>
      <section anchor="guidance-for-psks" numbered="true" removeInRFC="false" toc="include" pn="section-4.1">
        <name slugifiedName="name-guidance-for-psks">Guidance for PSKs</name>
        <t indent="0" pn="section-4.1-1">We first give requirements for creating and managing PSKs, followed
        by usability guidance, and then a discussion of RADIUS shared secrets
        and their interaction with PSKs.</t>
        <section anchor="psk-requirements" numbered="true" removeInRFC="false" toc="include" pn="section-4.1.1">
          <name slugifiedName="name-psk-requirements">PSK Requirements</name>
          <t indent="0" pn="section-4.1.1-1">Reuse of a PSK in multiple versions of TLS (e.g., TLS 1.2 and TLS
          1.3) is considered unsafe (see <xref section="E.7" sectionFormat="comma" target="RFC8446" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8446#appendix-E.7" derivedContent="RFC8446"/>).  Where TLS 1.3 binds the PSK to a particular
          key derivation function (KDF), TLS 1.2 does not.  This binding means that
          it is possible to use the same PSK in different hashes, leading to
          the potential for attacking the PSK by comparing the hash outputs.
          While there are no known insecurities, these uses are not known to
          be secure, and should therefore be avoided.  For this reason, an
          implementation <bcp14>MUST NOT</bcp14> use the same PSK for TLS 1.3
          and for earlier versions of TLS. The exact manner in which this
          requirement is enforced is implementation-specific. One possibility
          is to have two different PSKs. Another possibility is to forbid the
          use of TLS versions less than TLS 1.3</t>
          <t indent="0" pn="section-4.1.1-2"><xref target="RFC9258" format="default" sectionFormat="of" derivedContent="RFC9258"/> adds a KDF to the import interface of
          (D)TLS 1.3, which binds the externally provided PSK to the protocol
          version.  That process is preferred to any trust-on-first-use (TOFU) mechanism.  In
          particular, that document:</t>
          <blockquote pn="section-4.1.1-3">
            <t indent="0" pn="section-4.1.1-3.1">... describes a mechanism for importing PSKs derived from
              external PSKs by including the target KDF, (D)TLS protocol
              version, and an optional context string to ensure
              uniqueness. This process yields a set of candidate PSKs, each of
              which are bound to a target KDF and protocol, that are separate
              from those used in (D)TLS 1.2 and prior versions. This expands
              what would normally have been a single PSK and identity into a
              set of PSKs and identities.</t>
          </blockquote>
          <t indent="0" pn="section-4.1.1-4">An implementation <bcp14>MUST NOT</bcp14> use the same PSK for
          TLS 1.3 and for earlier versions of TLS.  This requirement prevents
          reuse of a PSK with multiple TLS versions, which prevents the
          attacks discussed in <xref section="E.7" sectionFormat="comma" target="RFC8446" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8446#appendix-E.7" derivedContent="RFC8446"/>.  The exact manner in which this requirement is
          enforced is implementation-specific.  One possibility is to have two
          different PSKs.  Another possibility is to forbid the use of TLS
          versions less than TLS 1.3.</t>
          <t indent="0" pn="section-4.1.1-5">Implementations <bcp14>MUST</bcp14> follow the directions of
          <xref section="6" sectionFormat="comma" target="RFC9257" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9257#section-6" derivedContent="RFC9257"/> for the
          use of external PSKs in TLS.  That document provides extremely
          useful guidance on generating and using PSKs.</t>
          <t indent="0" pn="section-4.1.1-6">Implementations <bcp14>MUST</bcp14> support PSKs of at least 32
          octets in length, and <bcp14>SHOULD</bcp14> support PSKs of 64
          octets or more.  As the PSKs are generally hashed before being used
          in TLS, the useful entropy of a PSK is limited by the size of the
          hash output.  This output may be 256, 384, or 512 bits in length.
          Nevertheless, it is good practice for implementations to allow entry
          of PSKs of more than 64 octets, as the PSK may be in a form other
          than bare binary data.  Implementations that limit the PSK to a
          maximum of 64 octets are likely to use PSKs that have much less
          than 512 bits of entropy.  That is, a PSK with high entropy may be
          expanded via some construct (e.g., base32 as seen in <xref target="usability-guidance" format="default" sectionFormat="of" derivedContent="Section 4.1.2"/>)
          in order to make it easier for people to interact with.  Where 512
          bits of entropy are input to an encoding construct, the output may
          be larger than 64 octets.</t>
          <t indent="0" pn="section-4.1.1-7">Implementations <bcp14>MUST</bcp14> require that PSKs be at least
          16 octets in length.  That is, short PSKs <bcp14>MUST NOT</bcp14> be
          permitted to be used, and PSKs <bcp14>MUST</bcp14> be random.  The
          strength of the PSK is not determined by the length of the PSK, but
          instead by the number of bits of entropy that it contains.  People
          are not good at creating data with high entropy, so a source of
          cryptographically secure random numbers <bcp14>MUST</bcp14> be
          used.</t>
          <t indent="0" pn="section-4.1.1-8">Where user passwords are generally intended to be remembered and
          entered by people on a regular basis, PSKs are intended to be
          entered once, and then automatically saved in a system
          configuration.  As such, due to the limited entropy of passwords,
          they are not acceptable for use with TLS-PSK, and would only be
          acceptable for use with a password-authenticated key exchange (PAKE)
          TLS method <xref target="RFC8492" format="default" sectionFormat="of" derivedContent="RFC8492"/>.  Implementations
          <bcp14>MUST</bcp14> therefore support entry and storage of PSKs as
          undistinguished octets.</t>
          <t indent="0" pn="section-4.1.1-9">We also incorporate by reference the requirements of <xref section="10.2" sectionFormat="comma" target="RFC7360" format="default" derivedLink="https://rfc-editor.org/rfc/rfc7360#section-10.2" derivedContent="RFC7360"/> when using
          PSKs.</t>
          <t indent="0" pn="section-4.1.1-10">It may be tempting for servers to implement a TOFU policy with
          respect to clients.  Such behavior is <bcp14>NOT RECOMMENDED</bcp14>.  When servers receive a connection from an
          unknown client, they <bcp14>SHOULD</bcp14> log the PSK Identity,
          source IP address, and any other information that may be relevant.
          An administrator can then later look at the logs and determine the
          appropriate action to take.</t>
        </section>
        <section anchor="usability-guidance" numbered="true" removeInRFC="false" toc="include" pn="section-4.1.2">
          <name slugifiedName="name-usability-guidance">Usability Guidance</name>
          <t indent="0" pn="section-4.1.2-1">PSKs in their purest form are opaque tokens, represented as
          an undistinguished series of octets.  Where PSKs are expected to be
          managed automatically by scripted methods, this format is
          acceptable.  However, in some cases it is necessary for
          administrators to share PSKs, in which case human-readable formats
          may be useful.  Implementations <bcp14>SHOULD</bcp14> support
          entering PSKs as both binary data and via a human-readable form
          such as hex encoding.</t>
          <t indent="0" pn="section-4.1.2-2">Implementations <bcp14>SHOULD</bcp14> use a human-readable form
          of PSKs for interfaces that are intended to be used by people, and
          <bcp14>SHOULD</bcp14> allow for binary data to be entered via an
          application programming interface (API).  Implementations
          <bcp14>SHOULD</bcp14> also allow for PSKs to be displayed in the hex
          encoding mentioned above, so that administrators can manually verify
          that a particular PSK is being used.</t>
          <t indent="0" pn="section-4.1.2-3">When using PSKs, administrators <bcp14>SHOULD</bcp14> use PSKs of
          at least 24 octets that are generated using a source of cryptographically
          secure random numbers.  Implementers needing a secure random number
          generator should see <xref target="RFC8937" format="default" sectionFormat="of" derivedContent="RFC8937"/> for further
          guidance.  PSKs are not passwords, and administrators should not try
          to manually create PSKs.</t>
          <t indent="0" pn="section-4.1.2-4">In order to guide implementers and administrators, we give
          example commands below that generate random PSKs from a locally
          secure source.  While some commands may not work on some systems, one
          of the commands should succeed.  The intent here is to document a
          concise and simple example of creating PSKs that are both secure
          and human-manageable.  This document does not mandate that the
          PSKs follow this format or any other format.</t>
          <sourcecode type="shell" markers="false" pn="section-4.1.2-5">
openssl rand -base64 16

dd if=/dev/urandom bs=1 count=16 | base64

dd if=/dev/urandom bs=1 count=16 | base32

dd if=/dev/urandom bs=1 count=16 | (hexdump -ve '/1 "%02x"' &amp;&amp; echo)
</sourcecode>
          <t indent="0" pn="section-4.1.2-6">Only one of the above commands should be run; there is no need to
          run all of them.  Each command reads 128 bits (16 octets) of random
          data from a secure source, and encodes it as printable and readable
          ASCII.  This form of PSK will be accepted by any implementation
          that supports at least 32 octets for PSKs.  Larger PSKs can be
          generated by changing the "16" number to a larger value.  The above
          derivation assumes that the random source returns one bit of entropy
          for every bit of randomness that is returned.  Sources failing that
          assumption are <bcp14>NOT RECOMMENDED</bcp14>.</t>
        </section>
        <section anchor="interaction-between-psks-and-radius-shared-secrets" numbered="true" removeInRFC="false" toc="include" pn="section-4.1.3">
          <name slugifiedName="name-interaction-between-psks-an">Interaction Between PSKs and RADIUS Shared Secrets</name>
          <t indent="0" pn="section-4.1.3-1">Any shared secret used for RADIUS/UDP or RADIUS/TLS <bcp14>MUST NOT</bcp14> be used for TLS-PSK.</t>
          <t indent="0" pn="section-4.1.3-2">It is <bcp14>RECOMMENDED</bcp14> that RADIUS clients and servers
          track all used shared secrets and PSKs, and then verify that the
          following requirements all hold true:</t>
          <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-4.1.3-3">
            <li pn="section-4.1.3-3.1">
              <t indent="0" pn="section-4.1.3-3.1.1">no shared secret is used for more than one RADIUS client</t>
            </li>
            <li pn="section-4.1.3-3.2">
              <t indent="0" pn="section-4.1.3-3.2.1">no PSK is used for more than one RADIUS client</t>
            </li>
            <li pn="section-4.1.3-3.3">
              <t indent="0" pn="section-4.1.3-3.3.1">no shared secret is used as a PSK</t>
            </li>
          </ul>
          <t indent="0" pn="section-4.1.3-4">Note that the shared secret of "radsec" given in <xref target="RFC6614" format="default" sectionFormat="of" derivedContent="RFC6614"/> can be used across multiple clients, as that
          value is mandated by the specification.  The intention here is to
          recommend best practices for administrators who enter site-local
          shared secrets.</t>
          <t indent="0" pn="section-4.1.3-5">There may be use cases for using one shared secret across
          multiple RADIUS clients.  There may similarly be use cases for
          sharing a PSK across multiple RADIUS clients.  Details of the
          possible attacks on reused PSKs are given in <xref section="4.1" sectionFormat="comma" target="RFC9257" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9257#section-4.1" derivedContent="RFC9257"/>.</t>
          <t indent="0" pn="section-4.1.3-6">There are no known use cases for using a PSK as a shared secret,
          or vice versa.</t>
          <t indent="0" pn="section-4.1.3-7">Implementations <bcp14>MUST</bcp14> reject configuration attempts
          that try to use the same value for the PSK and shared secret.  To
          prevent administrative errors, implementations should not have
          interfaces that confuse PSKs and shared secrets or that allow
          both PSKs and shared secrets to be entered at the same time.  There
          is too much of a temptation for administrators to enter the same
          value in both fields, which would violate the limitations given
          above.  Similarly, using a "shared secret" field as a way for
          administrators to enter PSKs is bad practice.  The PSK entry fields
          need to be labeled as being related to PSKs, and not to shared
          secrets.</t>
        </section>
      </section>
      <section anchor="psk-identities" numbered="true" removeInRFC="false" toc="include" pn="section-4.2">
        <name slugifiedName="name-psk-identities">PSK Identities</name>
        <t indent="0" pn="section-4.2-1"><xref section="5.1" sectionFormat="comma" target="RFC4279" format="default" derivedLink="https://rfc-editor.org/rfc/rfc4279#section-5.1" derivedContent="RFC4279"/>
        requires that PSK Identities be encoded in UTF-8 format.  However,
        <xref section="4.2.11" sectionFormat="comma" target="RFC8446" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8446#section-4.2.11" derivedContent="RFC8446"/>
        describes the "Pre-Shared Key Extension" and defines the ticket as an
        opaque string: "opaque identity&lt;1..2<sup>16</sup>-1&gt;;".  This PSK is then
        used in <xref section="4.6.1" sectionFormat="comma" target="RFC8446" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8446#section-4.6.1" derivedContent="RFC8446"/>
        for resumption.</t>
        <t indent="0" pn="section-4.2-2">These definitions appear to be in conflict.  This conflict is
        addressed in <xref section="6.1.1" sectionFormat="comma" target="RFC9257" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9257#section-6.1.1" derivedContent="RFC9257"/>, which discusses requirements for encoding and
        comparison of PSK Identities.  Systems <bcp14>MUST</bcp14> follow the
        directions of <xref section="6.1.1" sectionFormat="comma" target="RFC9257" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9257#section-6.1.1" derivedContent="RFC9257"/> when using or comparing PSK Identities for
        RADIUS/TLS.  Implementations <bcp14>MUST</bcp14> follow the
        recommendations of <xref target="RFC8265" format="default" sectionFormat="of" derivedContent="RFC8265"/> for handling PSK Identity
        strings.</t>
        <t indent="0" pn="section-4.2-3">In general, implementers should allow for external PSK Identities
        to follow <xref target="RFC4279" format="default" sectionFormat="of" derivedContent="RFC4279"/> and be UTF-8, while PSK Identities
        provisioned as part of resumption are automatically provisioned, and
        therefore follow <xref target="RFC8446" format="default" sectionFormat="of" derivedContent="RFC8446"/>.</t>
        <t indent="0" pn="section-4.2-4">Note that the PSK Identity is sent in the clear, and is therefore
        visible to attackers.  Where privacy is desired, the PSK Identity
        could be either an opaque token generated cryptographically, or
        perhaps in the form of a Network Access Identifier (NAI) <xref target="RFC7542" format="default" sectionFormat="of" derivedContent="RFC7542"/>, where the "user" portion is an opaque token.  For
        example, an NAI could be "68092112@example.com".  If the attacker
        already knows that the client is associated with "example.com", then
        using that domain name in the PSK Identity offers no additional
        information.  In contrast, the "user" portion needs to be both unique
        to the client and private, so using an opaque token is a more
        secure approach.</t>
        <t indent="0" pn="section-4.2-5">Implementations <bcp14>MUST</bcp14> support PSK Identities of 128
        octets, and <bcp14>SHOULD</bcp14> support longer PSK Identities.  We
        note that while TLS provides for PSK Identities of up to 2<sup>16</sup>-1 octets
        in length, there are few practical uses for extremely long PSK
        Identities.</t>
        <t indent="0" pn="section-4.2-6">It is up to administrators and implementations as to how they
        differentiate external PSK Identities from session resumption PSK
        Identities used in TLS 1.3 session tickets.  While <xref section="6.1.2" sectionFormat="comma" target="RFC9257" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9257#section-6.1.2" derivedContent="RFC9257"/> suggests the
        identities should be unique, it offers no concrete steps for how this
        differentiation may be done.</t>
        <t indent="0" pn="section-4.2-7">One approach could be to have externally provisioned PSK Identities
        contain an NAI such as what is described above, while session resumption PSK
        Identities contain large blobs of opaque, encrypted, and authenticated
        text.  It should then be relatively straightforward to differentiate
        the two types of identities.  One is UTF-8, the other is not.  One is
        unauthenticated, the other is authenticated.</t>
        <t indent="0" pn="section-4.2-8">Servers <bcp14>MUST</bcp14> assign and/or track session resumption
        PSK Identities in a way that facilities the ability to distinguish
        those identities from externally configured PSK Identities, and that
        enables them to both find and validate the session resumption PSK.
        See <xref target="resumption" format="default" sectionFormat="of" derivedContent="Section 6.2.3"/> below for more discussion of issues around
        resumption.</t>
        <t indent="0" pn="section-4.2-9">A sample validation flow for TLS-PSK Identities could be performed
        via the following steps:</t>
        <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-4.2-10">
          <li pn="section-4.2-10.1" derivedCounter="1.">PSK Identities provided via an administration interface are
          enforced to be only UTF-8 on both client and server.</li>
          <li pn="section-4.2-10.2" derivedCounter="2.">The client treats session tickets received from the server as
          opaque blobs.</li>
          <li pn="section-4.2-10.3" derivedCounter="3.">When the server issues session tickets for resumption, the
          server ensures that they are not valid UTF-8.</li>
          <li pn="section-4.2-10.4" derivedCounter="4.">One way to do this is to use stateless resumption with a forced
          non-UTF-8 key_name per <xref section="4.6.1" sectionFormat="comma" target="RFC8446" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8446#section-4.6.1" derivedContent="RFC8446"/>, such as by setting one octet to 0x00.</li>
          <li pn="section-4.2-10.5" derivedCounter="5.">
            <t indent="0" pn="section-4.2-10.5.1">When receiving TLS, the server receives a Client-Hello containing
	    a PSK, and checks if the identity is valid UTF-8:</t>
            <ol type="%p%d." indent="adaptive" spacing="normal" start="1" pn="section-4.2-10.5.2">
              <li pn="section-4.2-10.5.2.1" derivedCounter="5.1.">
                <t indent="0" pn="section-4.2-10.5.2.1.1">If yes, it searches for a preconfigured client that matches that identity.</t>
                <ol type="5.1.%d." indent="adaptive" spacing="normal" start="1" pn="section-4.2-10.5.2.1.2">
                  <li pn="section-4.2-10.5.2.1.2.1" derivedCounter="5.1.1.">If the identity is found, it authenticates the client via PSK.</li>
                  <li pn="section-4.2-10.5.2.1.2.2" derivedCounter="5.1.2.">Else, the identity is invalid, and the server closes the connection.</li>
                </ol>
              </li>
              <li pn="section-4.2-10.5.2.2" derivedCounter="5.2.">
                <t indent="0" pn="section-4.2-10.5.2.2.1">If not, try resumption, which is usually handled by a TLS library.</t>
                <ol type="5.2.%d." indent="adaptive" spacing="normal" start="1" pn="section-4.2-10.5.2.2.2">
                  <li pn="section-4.2-10.5.2.2.2.1" derivedCounter="5.2.1.">If the TLS library verifies the session ticket, then resumption has happened, and the connection is established.</li>
                  <li pn="section-4.2-10.5.2.2.2.2" derivedCounter="5.2.2.">Else, the server ignores the session ticket, and performs a normal TLS handshake with a certificate.</li>
                </ol>
              </li>
            </ol>
          </li>
        </ol>
        <t indent="0" pn="section-4.2-11">This validation flow is only suggested.  Other validation methods are possible.</t>
        <section anchor="security-of-psk-identities" numbered="true" removeInRFC="false" toc="include" pn="section-4.2.1">
          <name slugifiedName="name-security-of-psk-identities">Security of PSK Identities</name>
          <t indent="0" pn="section-4.2.1-1">We note that the PSK Identity is a field created by the
          connecting client.  Since the client is untrusted until both the
          identity and PSK have been verified, both of those fields
          <bcp14>MUST</bcp14> be treated as untrusted.  That is, a well-formed
          PSK Identity is likely to be in UTF-8 format, due to the
          requirements of <xref section="5.1" sectionFormat="comma" target="RFC4279" format="default" derivedLink="https://rfc-editor.org/rfc/rfc4279#section-5.1" derivedContent="RFC4279"/>.  However, implementations <bcp14>MUST</bcp14>
          support managing PSK Identities as a set of undistinguished
          octets.</t>
          <t indent="0" pn="section-4.2.1-2">It is not safe to use a raw PSK Identity to look up a
          corresponding PSK.  The PSK may come from an untrusted source and
          may contain invalid or malicious data.  For example, the identity
          may:</t>
          <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-4.2.1-3">
            <li pn="section-4.2.1-3.1">have an incorrect UTF-8 format,</li>
            <li pn="section-4.2.1-3.2">contain data that forms an injection attack for SQL, the
	    Lightweight Directory Access Protocol (LDAP), Representational
	    State Transfer (REST), or shell meta characters, or</li>
            <li pn="section-4.2.1-3.3">contain embedded NUL octets that are incompatible with APIs
	    that expect NUL terminated strings.</li>
          </ul>
          <t indent="0" pn="section-4.2.1-4">The identity may also be up to 65535 octets long.</t>
          <t indent="0" pn="section-4.2.1-5">As such, implementations <bcp14>MUST</bcp14> validate the
          identity prior to it being used as a lookup key.  When the identity
          is passed to an external API (e.g., database lookup),
          implementations <bcp14>MUST</bcp14> either escape any characters in
          the identity that are invalid for that API, or else reject the
          identity entirely.  The exact form of any escaping depends on the
          API, and we cannot document all possible methods here.  However, a
          few basic validation rules are suggested, as outlined below.  Any
          identity that is rejected by these validation rules
          <bcp14>MUST</bcp14> cause the server to close the TLS
          connection.</t>
          <t indent="0" pn="section-4.2.1-6">The suggested validation rules for identities used outside of resumption are as follows:</t>
          <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-4.2.1-7">
            <li pn="section-4.2.1-7.1">
              <t indent="0" pn="section-4.2.1-7.1.1">Identities <bcp14>MUST</bcp14> be checked to see if they have
              been provisioned as a resumption PSK.  If so, then the session
              can be resumed, subject to any policies around resumption.</t>
            </li>
            <li pn="section-4.2.1-7.2">
              <t indent="0" pn="section-4.2.1-7.2.1">Identities longer than a fixed maximum <bcp14>SHOULD</bcp14>
              be rejected.  The limit is implementation dependent, but
              <bcp14>SHOULD NOT</bcp14> be less than 128, and <bcp14>SHOULD NOT</bcp14> be more than 1024.  There is no purpose to allowing
              extremely long identities, and allowing them does little more
              than complicate implementations.</t>
            </li>
            <li pn="section-4.2.1-7.3">
              <t indent="0" pn="section-4.2.1-7.3.1">Identities configured by administrators <bcp14>SHOULD</bcp14>
              be in UTF-8 format, and <bcp14>SHOULD</bcp14> be in the NAI
              format from <xref target="RFC7542" format="default" sectionFormat="of" derivedContent="RFC7542"/>.  While <xref section="4.2.11" sectionFormat="comma" target="RFC8446" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8446#section-4.2.11" derivedContent="RFC8446"/>
              defines the PSK Identity as "opaque identity&lt;1..2<sup>16</sup>-1&gt;",
              it is useful for administrators to manage human-readable
              identities in a recognizable format.</t>
              <t indent="0" pn="section-4.2.1-7.3.2">This suggestion makes it easier to distinguish TLS-PSK
	      Identities from TLS 1.3 resumption identities.  It also allows
	      implementations to more easily filter out unexpected or bad
	      identities, and then to close inappropriate TLS connections.</t>
            </li>
          </ul>
          <t indent="0" pn="section-4.2.1-8">It is <bcp14>RECOMMENDED</bcp14> that implementations extend
          these rules with any additional validation that is found to be
          useful.  For example, implementations and/or deployments could both
          generate PSK Identities in a particular format for passing to client
          systems, and then also verify that any received identity matches
          that format.  For example, a site could generate PSK Identities
          that are composed of characters in the local language.  The site
          could then reject identities that contain characters from other
          languages, even if those characters are valid UTF-8.</t>
          <t indent="0" pn="section-4.2.1-9">The purpose of these rules is to help administrators and
          implementers more easily manage systems using TLS-PSK, while also
          minimizing complexity and protecting from potential attackers'
          traffic.  The rules follow a principle of "discard bad traffic
          quickly", which helps to improve system stability and
          performance.</t>
        </section>
      </section>
      <section anchor="sharing" numbered="true" removeInRFC="false" toc="include" pn="section-4.3">
        <name slugifiedName="name-psk-and-psk-identity-sharin">PSK and PSK Identity Sharing</name>
        <t indent="0" pn="section-4.3-1">While administrators may desire to share PSKs and/or PSK Identities
        across multiple systems, such usage is <bcp14>NOT RECOMMENDED</bcp14>.
        Details of the possible attacks on reused PSKs are given in <xref section="4.1" sectionFormat="comma" target="RFC9257" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9257#section-4.1" derivedContent="RFC9257"/>.</t>
        <t indent="0" pn="section-4.3-2">Implementations <bcp14>MUST</bcp14> support the ability to
        configure a unique PSK and PSK Identity for each possible
        client-server relationship.  This configuration allows administrators
        desiring security to use unique PSKs for each such relationship.  This
        configuration is also compatible with the practice of administrators
        who wish to reuse PSKs and PSK Identities where local policies
        permit.</t>
        <t indent="0" pn="section-4.3-3">Implementations <bcp14>SHOULD</bcp14> warn administrators if the
        same PSK Identity and/or PSK is used for multiple client-server
        relationships.</t>
      </section>
      <section anchor="psk-lifetimes" numbered="true" removeInRFC="false" toc="include" pn="section-4.4">
        <name slugifiedName="name-psk-lifetimes">PSK Lifetimes</name>
        <t indent="0" pn="section-4.4-1">Unfortunately, <xref target="RFC9257" format="default" sectionFormat="of" derivedContent="RFC9257"/> offers no guidance on PSK
        lifetimes other than to note in Section <xref target="RFC9257" sectionFormat="bare" section="4.2" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9257#section-4.2" derivedContent="RFC9257"/> that:</t>
        <blockquote pn="section-4.4-2">
          <t indent="0" pn="section-4.4-2.1">Forward security may be achieved by using a PSK-DH mode or by
            using PSKs with short lifetimes.</t>
        </blockquote>
        <t indent="0" pn="section-4.4-3">It is <bcp14>RECOMMENDED</bcp14> that PSKs be rotated regularly.
        We offer no additional guidance on how often this process should
        occur.  Changing PSKs has a non-zero cost.  It is therefore up to
        administrators to determine how best to balance the cost of changing
        the PSK against the cost of a potential PSK compromise.</t>
        <t indent="0" pn="section-4.4-4">TLS-PSK <bcp14>MUST</bcp14> use modes such as PSK-DH or ECDHE_PSK
        <xref target="RFC5489" format="default" sectionFormat="of" derivedContent="RFC5489"/> that provide forward secrecy.  Failure to
        use such modes would mean that compromise of a PSK would allow an
        attacker to decrypt all sessions that had used that PSK.</t>
        <t indent="0" pn="section-4.4-5">As the PSKs are looked up by identity, the PSK Identity
        <bcp14>MUST</bcp14> also be changed when the PSK changes.</t>
        <t indent="0" pn="section-4.4-6">Servers <bcp14>SHOULD</bcp14> track when a connection was last
        received for a particular PSK Identity, and <bcp14>SHOULD</bcp14>
        automatically invalidate credentials when a client has not connected
        for an extended period of time.  This process helps to mitigate the
        issue of credentials being leaked when a device is stolen or
        discarded.</t>
      </section>
    </section>
    <section anchor="guidance-for-radius-clients" numbered="true" removeInRFC="false" toc="include" pn="section-5">
      <name slugifiedName="name-guidance-for-radius-clients">Guidance for RADIUS Clients</name>
      <t indent="0" pn="section-5-1">Client implementations <bcp14>MUST</bcp14> allow the use of a
      Pre-Shared Key (PSK) for RADIUS/TLS. The client implementation can then
      provide a user interface flag that is "TLS yes / no", and also provide
      fields that ask for the PSK Identity and PSK itself.</t>
      <t indent="0" pn="section-5-2">For TLS 1.3, implementations <bcp14>MUST</bcp14> support the "psk_dhe_ke" PSK Exchange Mode as discussed in <xref target="RFC8446" sectionFormat="comma" section="4.2.9" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8446#section-4.2.9" derivedContent="RFC8446"/> and in <xref target="RFC9257" sectionFormat="comma" section="6" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9257#section-6" derivedContent="RFC9257"/>.  Implementations <bcp14>MUST</bcp14> implement the
      recommended cipher suites in <xref target="RFC9325" sectionFormat="comma" section="4.2" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9325#section-4.2" derivedContent="RFC9325"/> for TLS 1.2 and in <xref target="RFC8446" sectionFormat="comma" section="9.1" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8446#section-9.1" derivedContent="RFC8446"/> for TLS 1.3.  In
      order to future-proof these recommendations, we give the following
      recommendations.</t>
      <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-5-3">
        <li pn="section-5-3.1">
          <t indent="0" pn="section-5-3.1.1">Implementations <bcp14>SHOULD</bcp14> use the "Recommended"
	  cipher suites listed in the IANA "TLS Cipher Suites" registry:</t>
          <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-5-3.1.2">
            <li pn="section-5-3.1.2.1">
              <t indent="0" pn="section-5-3.1.2.1.1">For TLS 1.3, use the "psk_dhe_ke" PSK key exchange mode.</t>
            </li>
            <li pn="section-5-3.1.2.2">
              <t indent="0" pn="section-5-3.1.2.2.1">For TLS 1.2 and earlier, use cipher suites that require ephemeral keying.</t>
            </li>
          </ul>
        </li>
      </ul>
      <t indent="0" pn="section-5-4">If a client initiated a connection using a PSK with TLS 1.3 by
      including the PSK extension, it <bcp14>MUST</bcp14> close the
      connection if the server did not also select the PSK to
      continue the handshake.</t>
      <section anchor="psk-identities-1" numbered="true" removeInRFC="false" toc="include" pn="section-5.1">
        <name slugifiedName="name-psk-identities-2">PSK Identities</name>
        <t indent="0" pn="section-5.1-1">This section offers advice on both requirements for PSK Identities and on usability.</t>
        <section anchor="psk-identity-requirements" numbered="true" removeInRFC="false" toc="include" pn="section-5.1.1">
          <name slugifiedName="name-psk-identity-requirements">PSK Identity Requirements</name>
          <t indent="0" pn="section-5.1.1-1"><xref target="RFC6614" format="default" sectionFormat="of" derivedContent="RFC6614"/> is silent on the subject of PSK
          Identities, which is an issue that we correct here.  Guidance is
          required on the use of PSK Identities, as the need to manage
          identities associated with PSKs is a new requirement for both Network Access Server (NAS)
          management interfaces and RADIUS
          servers.</t>
          <t indent="0" pn="section-5.1.1-2">RADIUS systems implementing TLS-PSK <bcp14>MUST</bcp14> support
          identities as per <xref section="5.3" sectionFormat="comma" target="RFC4279" format="default" derivedLink="https://rfc-editor.org/rfc/rfc4279#section-5.3" derivedContent="RFC4279"/> and <bcp14>MUST</bcp14> enable configuring
          TLS-PSK Identities in management interfaces as per <xref section="5.4" sectionFormat="comma" target="RFC4279" format="default" derivedLink="https://rfc-editor.org/rfc/rfc4279#section-5.4" derivedContent="RFC4279"/>.</t>
          <t indent="0" pn="section-5.1.1-3">The historic methods of signing RADIUS packets have not yet been
          broken, but they are believed to be much less secure than modern
          TLS.  Therefore, when a RADIUS shared secret is used to sign
          RADIUS/UDP or RADIUS/TCP packets, that shared secret <bcp14>MUST NOT</bcp14> be used with TLS-PSK.  If the secrets were to be reused,
          then an attack on historic RADIUS cryptography could be trivially
          leveraged to decrypt TLS-PSK sessions.</t>
          <t indent="0" pn="section-5.1.1-4">With TLS-PSK, RADIUS/TLS clients <bcp14>MUST</bcp14> permit the
          configuration of a RADIUS server IP address or host name, because
          dynamic server lookups <xref target="RFC7585" format="default" sectionFormat="of" derivedContent="RFC7585"/> can only be used if
          servers use certificates.</t>
        </section>
        <section anchor="usability-guidance-1" numbered="true" removeInRFC="false" toc="include" pn="section-5.1.2">
          <name slugifiedName="name-usability-guidance-2">Usability Guidance</name>
          <t indent="0" pn="section-5.1.2-1">In order to prevent confusion between shared secrets and
          TLS-PSKs, management interfaces and APIs need to label PSK fields as
          "PSK" or "TLS-PSK", rather than as "shared secret".</t>
        </section>
      </section>
    </section>
    <section anchor="guidance-for-radius-servers" numbered="true" removeInRFC="false" toc="include" pn="section-6">
      <name slugifiedName="name-guidance-for-radius-servers">Guidance for RADIUS Servers</name>
      <t indent="0" pn="section-6-1">In order to support clients with TLS-PSK, server implementations
      <bcp14>MUST</bcp14> allow the use of a PSK (TLS-PSK) for
      RADIUS/TLS.</t>
      <t indent="0" pn="section-6-2">Systems that act as both client and server at the same time
      <bcp14>MUST NOT</bcp14> share or reuse PSK Identities between incoming
      and outgoing connections.  Doing so would open up the systems to attack,
      as discussed in <xref section="4.1" sectionFormat="comma" target="RFC9257" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9257#section-4.1" derivedContent="RFC9257"/>.</t>
      <t indent="0" pn="section-6-3">For TLS 1.3, implementations <bcp14>MUST</bcp14> support the "psk_dhe_ke"
      PSK Exchange Mode as discussed in <xref section="4.2.9" sectionFormat="comma" target="RFC8446" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8446#section-4.2.9" derivedContent="RFC8446"/> and in <xref section="6" sectionFormat="comma" target="RFC9257" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9257#section-6" derivedContent="RFC9257"/>.  Implementations
      <bcp14>MUST</bcp14> implement the recommended cipher suites in <xref section="4.2" sectionFormat="comma" target="RFC9325" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9325#section-4.2" derivedContent="RFC9325"/> for TLS 1.2 and
      in <xref section="9.1" sectionFormat="comma" target="RFC8446" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8446#section-9.1" derivedContent="RFC8446"/> for TLS
      1.3.  In order to future-proof these recommendations, we give the
      following recommendations.</t>
      <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-6-4">
        <li pn="section-6-4.1">
          <t indent="0" pn="section-6-4.1.1">Implementations <bcp14>SHOULD</bcp14> use the "Recommended"
          cipher suites listed in the IANA "TLS Cipher Suites" registry:
          </t>
          <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-6-4.1.2">
            <li pn="section-6-4.1.2.1">
              <t indent="0" pn="section-6-4.1.2.1.1">For TLS 1.3, use the "psk_dhe_ke" PSK key exchange mode.</t>
            </li>
            <li pn="section-6-4.1.2.2">
              <t indent="0" pn="section-6-4.1.2.2.1">For TLS 1.2 and earlier, use cipher suites that require ephemeral keying.</t>
            </li>
          </ul>
        </li>
      </ul>
      <t indent="0" pn="section-6-5">The following section(s) describe guidance for RADIUS server
      implementations and deployments.  We first give an overview of current
      practices, and then extend and/or replace those practices for
      TLS-PSK.</t>
      <section anchor="current-practices" numbered="true" removeInRFC="false" toc="include" pn="section-6.1">
        <name slugifiedName="name-current-practices">Current Practices</name>
        <t indent="0" pn="section-6.1-1">RADIUS identifies clients by source IP address (see <xref target="RFC2865" format="default" sectionFormat="of" derivedContent="RFC2865"/> and <xref target="RFC6613" format="default" sectionFormat="of" derivedContent="RFC6613"/>) or by client
        certificate (see <xref target="RFC6614" format="default" sectionFormat="of" derivedContent="RFC6614"/> and <xref target="RFC7585" format="default" sectionFormat="of" derivedContent="RFC7585"/>).
        Neither of these approaches work for TLS-PSK.  This section describes
        current practices and mandates behavior for servers that use
        TLS-PSK.</t>
        <t indent="0" pn="section-6.1-2">A RADIUS/UDP server is typically configured with a set of
        information per client, which includes at least the source IP address
        and shared secret.  When the server receives a RADIUS/UDP packet, it
        looks up the source IP address, finds a client definition, and
        therefore the shared secret.  The packet is then authenticated (or
        not) using that shared secret.</t>
        <t indent="0" pn="section-6.1-3">That is, the IP address is treated as the client's identity, and the
        shared secret is used to prove the client's authenticity and shared
        trust.  The set of clients forms a logical database "client table"
        with the IP address as the key.</t>
        <t indent="0" pn="section-6.1-4">A server may be configured with additional site-local policies
        associated with that client.  For example, a client may be marked up
        as being a Wi-Fi Access Point, a VPN concentrator, etc.  Different
        clients may be permitted to send different kinds of requests, where
        some may send Accounting-Request packets, and other clients may not
        send accounting packets.</t>
      </section>
      <section anchor="practices-for-tls-psk" numbered="true" removeInRFC="false" toc="include" pn="section-6.2">
        <name slugifiedName="name-practices-for-tls-psk">Practices for TLS-PSK</name>
        <t indent="0" pn="section-6.2-1">We define practices for TLS-PSK by analogy with the RADIUS/UDP
        use case and by extending the additional policies associated with the
        client.  The PSK Identity replaces the source IP address as the client
        identifier.  The PSK replaces the shared secret as proof of client
        authenticity and shared trust.  However, systems implementing
        RADIUS/TLS <xref target="RFC6614" format="default" sectionFormat="of" derivedContent="RFC6614"/> and RADIUS/DTLS <xref target="RFC7360" format="default" sectionFormat="of" derivedContent="RFC7360"/> <bcp14>MUST</bcp14> still use the shared secret as
        discussed in those specifications.  Any PSK is only used by the TLS
        layer and has no effect on the RADIUS data that is being
        transported.  That is, the RADIUS data transported in a TLS tunnel is
        the same no matter if client authentication is done via PSK or by
        client certificates.  The encoding of the RADIUS data is entirely
        unaffected by the use (or not) of PSKs and client certificates.</t>
        <t indent="0" pn="section-6.2-2">In order to securely support dynamic source IP addresses for
        clients, we also require that servers limit clients based on a network
        range.  The alternative would be to suggest that RADIUS servers allow
        any source IP address to connect and try TLS-PSK, which could be a
        security risk.  When RADIUS servers do no source IP address filtering,
        it is easier for attackers to send malicious traffic to the server.
        An issue with a TLS library or even a TCP/IP stack could permit the
        attacker to gain unwarranted access.  In contrast, when IP address
        filtering is done, attackers generally must first gain access to a
        secure network before attacking the RADIUS server.</t>
        <t indent="0" pn="section-6.2-3">Even where dynamic discovery <xref target="RFC7585" format="default" sectionFormat="of" derivedContent="RFC7585"/> is not used,
        the use of TLS-PSK across unrelated organizations requires that those
        organizations share PSKs.  Such sharing makes it easier for a client
        to impersonate a server, and vice versa.  In contrast, when
        certificates are used, such impersonations are impossible. It is
        therefore <bcp14>NOT RECOMMENDED</bcp14> to use TLS-PSK across
        organizational boundaries.</t>
        <t indent="0" pn="section-6.2-4">When TLS-PSK is used in an environment where both client and server
        are part of the same organization, then impersonations only affect
        that organization.  As TLS offers significant advantages over
        RADIUS/UDP, it is <bcp14>RECOMMENDED</bcp14> that organizations use
        RADIUS/TLS with TLS-PSK to replace RADIUS/UDP for all systems managed
        within the same organization.  While such systems are generally
        located inside of private networks, there are no known security issues
        with using TLS-PSK for RADIUS/TLS connections across the public
        Internet.</t>
        <t indent="0" pn="section-6.2-5">If a client system is compromised, its complete configuration is
        exposed to the attacker.  Exposing a client certificate means that the
        attacker can pretend to be the client.  In contrast, exposing a PSK
        means that the attacker cannot only pretend to be the client, but can
        also pretend to be the server.</t>
        <t indent="0" pn="section-6.2-6">The main benefit of TLS-PSK, therefore, is that its operational
        processes are similar to that used for managing RADIUS/UDP, while
        gaining the increased security of TLS.  However, it is still
        beneficial for servers to perform IP address filtering, in order to
        further limit their exposure to attacks.</t>
        <section anchor="ip-filtering" numbered="true" removeInRFC="false" toc="include" pn="section-6.2.1">
          <name slugifiedName="name-ip-filtering">IP Filtering</name>
          <t indent="0" pn="section-6.2.1-1">A server supporting this specification <bcp14>MUST</bcp14>
          perform IP address filtering on incoming connections.  There are few
          reasons for a server to have a default configuration that allows
          connections from any source IP address.</t>
          <t indent="0" pn="section-6.2.1-2">A TLS-PSK server <bcp14>MUST</bcp14> be configurable with a set
          of "allowed" network ranges from which clients are permitted to
          connect.  Any connection from outside of the allowed range(s)
          <bcp14>MUST</bcp14> be rejected before any PSK Identity is checked.
          It is <bcp14>RECOMMENDED</bcp14> that servers support IP address
          filtering even when TLS-PSK is not used.</t>
          <t indent="0" pn="section-6.2.1-3">The "allowed" network ranges could be implemented as a global
          list, or one or more network ranges could be tied to a client or
          clients.  The intent here is to allow connections to be filtered by
          source IP address and to allow clients to be limited to a subset of
          network addresses.  The exact method and representation of that
          filtering is up to an implementation.</t>
          <t indent="0" pn="section-6.2.1-4">Conceptually, the set of IP addresses and ranges, along with
          permitted clients and their credentials, form a logical "client
          table" that the server uses to both filter and authenticate
          clients.  The client table should contain information such as
          allowed network ranges, PSK Identity and associated PSK, credentials
          for another TLS authentication method, or flags that indicate that
          the server should require a client certificate.</t>
          <t indent="0" pn="section-6.2.1-5">Once a server receives a connection, it checks the source IP
          address against the list of all allowed IP addresses or ranges in
          the client table.  If none match, the connection <bcp14>MUST</bcp14>
          be rejected.  That is, the connection <bcp14>MUST</bcp14> be from an
          authorized source IP address.</t>
          <t indent="0" pn="section-6.2.1-6">Once a connection has been established, the server <bcp14>MUST NOT</bcp14> process any application data inside of the TLS tunnel
          until the client has been authenticated.  Instead, the server
          normally receives a TLS-PSK Identity from the client.  The server
          then uses this identity to look up the client in the client table.
          If there is no matching client, the server <bcp14>MUST</bcp14> close
          the connection.  The server then also checks if this client
          definition allows this particular source IP address.  If the source
          IP address is not allowed, the server <bcp14>MUST</bcp14> close the
          connection.</t>
          <t indent="0" pn="section-6.2.1-7">Where the server does not receive TLS-PSK from the client, it
          proceeds with another authentication method such as client
          certificates.  Such requirements are discussed elsewhere, most
          notably in <xref target="RFC6614" format="default" sectionFormat="of" derivedContent="RFC6614"/> and <xref target="RFC7360" format="default" sectionFormat="of" derivedContent="RFC7360"/>.</t>
          <t indent="0" pn="section-6.2.1-8">An implementation may perform two independent IP address lookups:
          first to check if the connection is allowed at all, and second to
          check if the connection is authorized for this particular client.
          One or both checks may be used by a particular implementation.  The
          two sets of IP addresses can overlap, and implementations
          <bcp14>SHOULD</bcp14> support that capability.</t>
          <t indent="0" pn="section-6.2.1-9">Depending on the implementation, one or more clients may share a
          list of allowed network ranges.  Alternately, the allowed network
          ranges for two clients can overlap only partially, or not at all.
          All of these possibilities <bcp14>MUST</bcp14> be supported by the
          server implementation.</t>
          <t indent="0" pn="section-6.2.1-10">For example, a RADIUS server could be configured to accept
          connections from a source network of 192.0.2.0/24 or 2001:DB8::/32.
          The server could therefore discard any TLS connection request that
          comes from a source IP address outside of that network.  In that
          case, there is no need to examine the PSK Identity or to find the
          client definition.  Instead, the IP source filtering policy would
          deny the connection before any TLS communication had been
          performed.</t>
          <t indent="0" pn="section-6.2.1-11">As some clients may have dynamic IP addresses, it is possible for
          one PSK Identity to appear at different source IP addresses over
          time.  In addition, as there may be many clients behind one NAT
          gateway, there may be multiple RADIUS clients using one public IP
          address.  RADIUS servers <bcp14>MUST</bcp14> support multiple PSK
          Identifiers at one source IP address.</t>
          <t indent="0" pn="section-6.2.1-12">That is, a server needs to support multiple different clients
          within one network range, multiple clients behind a NAT, and one
          client having different IP addresses over time.  All of those
          use cases are common and necessary.</t>
          <t indent="0" pn="section-6.2.1-13">The following section describes these requirements in more detail.</t>
        </section>
        <section anchor="psk-authentication" numbered="true" removeInRFC="false" toc="include" pn="section-6.2.2">
          <name slugifiedName="name-psk-authentication">PSK Authentication</name>
          <t indent="0" pn="section-6.2.2-1">Once the source IP address has been verified to be allowed for
          this particular client, the server authenticates the TLS connection
          via the PSK taken from the client definition.  If the PSK is
          verified, the server then accepts the connection and proceeds with
          RADIUS/TLS as per <xref target="RFC6614" format="default" sectionFormat="of" derivedContent="RFC6614"/>.</t>
          <t indent="0" pn="section-6.2.2-2">If the PSK is not verified, then the server <bcp14>MUST</bcp14>
          close the connection.  While TLS provides for fallback to other
          authentication methods such as client certificates, there is no
          reason for a client to be configured simultaneously with multiple
          authentication methods.</t>
          <t indent="0" pn="section-6.2.2-3">A client <bcp14>MUST</bcp14> use only one authentication method
          for TLS.  An authentication method is either TLS-PSK, client
          certificates, or some other method supported by TLS.</t>
          <t indent="0" pn="section-6.2.2-4">That is, client configuration is relatively simple: use a
          particular set of credentials to authenticate to a particular
          server.  While clients may support multiple servers and fail-over or
          load-balancing, that configuration is generally orthogonal to the
          choice of which credentials to use.</t>
        </section>
        <section anchor="resumption" numbered="true" removeInRFC="false" toc="include" pn="section-6.2.3">
          <name slugifiedName="name-resumption">Resumption</name>
          <t indent="0" pn="section-6.2.3-1">It is <bcp14>NOT RECOMMENDED</bcp14> that servers enable
          resumption for sessions that use TLS-PSK.  There are few practical
          benefits to supporting resumption and many complexities.</t>
          <t indent="0" pn="section-6.2.3-2">However, some systems will need to support both TLS-PSK and
          other TLS-based authentication methods such as certificates, while
          also supporting session resumption.  It is therefore vital for
          servers to be able to distinguish the use case of TLS-PSK with
          preconfigured identities from TLS-PSK that is being used for
          resumptions.</t>
          <t indent="0" pn="section-6.2.3-3">The above discussion of PSK Identities is complicated by the use
          of PSKs for resumption in TLS 1.3.  A server that receives a PSK
          Identity via TLS typically cannot query the TLS layer to see if this
          identity is for a resumed session (which is possibly for another TLS
          authentication method), or is instead a static pre-provisioned
          identity.  This confusion complicates server implementations.</t>
          <t indent="0" pn="section-6.2.3-4">One way for a server to tell the difference between the two kinds
          of identities is via construction.  Identities used for resumption
          can be constructed via a fixed format, such as what is recommended by <xref section="4.6.1" sectionFormat="comma" target="RFC8446" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8446#section-4.6.1" derivedContent="RFC8446"/>.  A static
          pre-provisioned identity could be in the format of an NAI, as given in
          <xref target="RFC7542" format="default" sectionFormat="of" derivedContent="RFC7542"/>.  An implementation could therefore examine
          the incoming identity and determine from the identity alone what
          kind of authentication was being performed.</t>
          <t indent="0" pn="section-6.2.3-5">An alternative way for a server to distinguish the two kinds of
          identities is to maintain two tables.  One table would contain
          static identities, as the logical client table described above.
          Another table could be the table of identities handed out for
          resumption.  The server would then look up any PSK Identity in one
          table, and if it is not found, query the other one.  Either an identity would be
          found in a table, in which case it can be authenticated, or the
          identity would not be found in either table, in which case it is
          unknown, and the server <bcp14>MUST</bcp14> close the
          connection.</t>
          <t indent="0" pn="section-6.2.3-6">As suggested in <xref target="RFC8446" format="default" sectionFormat="of" derivedContent="RFC8446"/>, TLS-PSK peers
          <bcp14>MUST NOT</bcp14> store resumption PSKs or tickets (and
          associated cached data) for longer than 604800 seconds (7 days),
          regardless of the PSK or ticket lifetime.</t>
          <t indent="0" pn="section-6.2.3-7">Since resumption in TLS 1.3 uses PSK Identities and keys, it is
          <bcp14>NOT RECOMMENDED</bcp14> to permit resumption of sessions when
          TLS-PSK is used.  The use of resumption offers additional complexity
          with minimal additional benefits.</t>
          <t indent="0" pn="section-6.2.3-8">Where resumption is allowed with TLS-PSK, systems
          <bcp14>MUST</bcp14> cache data during the initial full handshake
          sufficiently enough to allow authorization decisions to be made during
          resumption. If the cached data cannot be retrieved securely,
          resumption <bcp14>MUST NOT</bcp14> be done.  Instead, the system
          <bcp14>MUST</bcp14> perform a full handshake.</t>
          <t indent="0" pn="section-6.2.3-9">The data that needs to be cached is typically information such
          as the original PSK Identity, along with any policies associated
          with that identity.</t>
          <t indent="0" pn="section-6.2.3-10">Information from the original TLS exchange (e.g., the original
          PSK Identity) as well as related information (e.g., source IP
          addresses) may change between the initial full handshake and
          resumption. This change creates a "time-of-check time-of-use"
          (TOCTOU) security vulnerability. A malicious or compromised client
          could supply one set of data during the initial authentication and
          a different set of data during resumption, potentially allowing them
          to obtain access that they should not have.</t>
          <t indent="0" pn="section-6.2.3-11">If any authorization or policy decisions were made with
          information that has changed between the initial full handshake and
          resumption, and if changes may lead to a different decision, such
          decisions <bcp14>MUST</bcp14> be reevaluated.  Systems
          <bcp14>MUST</bcp14> also reevaluate authorization and policy
          decisions during resumption, based on the information given in the
          new connection.  Servers <bcp14>MAY</bcp14> refuse to perform
          resumption where the information supplied during resumption does not
          match the information supplied during the original authentication.
          If a safe decision is not possible, servers <bcp14>MUST</bcp14>
          instead continue with a full handshake.</t>
        </section>
        <section anchor="interaction-with-other-tls-authentication-methods" numbered="true" removeInRFC="false" toc="include" pn="section-6.2.4">
          <name slugifiedName="name-interaction-with-other-tls-">Interaction with Other TLS Authentication Methods</name>
          <t indent="0" pn="section-6.2.4-1">When a server supports both TLS-PSK and client certificates, it
          <bcp14>MUST</bcp14> be able to accept authenticated connections from
          clients that may use either type of credentials, perhaps even from
          the same source IP address and at the same time.  That is, servers
          are required to both authenticate the client and also to filter
          clients by source IP address.  These checks both have to match in
          order for a client to be accepted.</t>
        </section>
      </section>
    </section>
    <section anchor="privacy-considerations" numbered="true" removeInRFC="false" toc="include" pn="section-7">
      <name slugifiedName="name-privacy-considerations">Privacy Considerations</name>
      <t indent="0" pn="section-7-1">We make no changes to <xref target="RFC6614" format="default" sectionFormat="of" derivedContent="RFC6614"/> and <xref target="RFC7360" format="default" sectionFormat="of" derivedContent="RFC7360"/>.</t>
    </section>
    <section anchor="security-considerations" numbered="true" removeInRFC="false" toc="include" pn="section-8">
      <name slugifiedName="name-security-considerations">Security Considerations</name>
      <t indent="0" pn="section-8-1">The primary focus of this document is addressing security considerations for RADIUS.</t>
      <t indent="0" pn="section-8-2">Previous specifications discuss security considerations for TLS-PSK
      in detail.  We refer the reader to <xref section="E.7" sectionFormat="of" target="RFC8446" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8446#appendix-E.7" derivedContent="RFC8446"/>, <xref target="RFC9257" format="default" sectionFormat="of" derivedContent="RFC9257"/>, and
      <xref target="RFC9258" format="default" sectionFormat="of" derivedContent="RFC9258"/>.  Those documents are newer than <xref target="RFC6614" format="default" sectionFormat="of" derivedContent="RFC6614"/> and <xref target="RFC7360" format="default" sectionFormat="of" derivedContent="RFC7360"/>, and therefore raise
      issues that were not considered during the initial design of RADIUS/TLS
      and RADIUS/DTLS.</t>
      <t indent="0" pn="section-8-3">Using TLS-PSK across the wider Internet for RADIUS can have different
      security considerations than for other protocols.  For example, if
      TLS-PSK was for client/server communication with HTTPS, then having a
      PSK be exposed or broken could affect one user's traffic.  In contrast,
      RADIUS contains credentials and personally identifiable information
      (PII) for many users.  As a result, an attacker being able to see inside
      of a TLS-PSK connection for RADIUS would result in substantial amounts
      of PII being leaked, possibly including passwords.</t>
      <t indent="0" pn="section-8-4">When modes providing forward secrecy are used (e.g., ECDHE_PSK as seen in <xref target="RFC5489" format="default" sectionFormat="of" derivedContent="RFC5489"/> and <xref target="RFC8442" format="default" sectionFormat="of" derivedContent="RFC8442"/>), such attacks are
      limited to future sessions, and historical sessions are still
      secure.</t>
    </section>
    <section anchor="iana-considerations" numbered="true" removeInRFC="false" toc="include" pn="section-9">
      <name slugifiedName="name-iana-considerations">IANA Considerations</name>
      <t indent="0" pn="section-9-1">This document has no IANA actions.</t>
    </section>
  </middle>
  <back>
    <references anchor="sec-combined-references" pn="section-10">
      <name slugifiedName="name-references">References</name>
      <references anchor="sec-normative-references" pn="section-10.1">
        <name slugifiedName="name-normative-references">Normative References</name>
        <reference anchor="RFC2119" target="https://www.rfc-editor.org/info/rfc2119" quoteTitle="true" derivedAnchor="RFC2119">
          <front>
            <title>Key words for use in RFCs to Indicate Requirement Levels</title>
            <author fullname="S. Bradner" initials="S." surname="Bradner"/>
            <date month="March" year="1997"/>
            <abstract>
              <t indent="0">In many standards track documents several words are used to signify the requirements in the specification. These words are often capitalized. This document defines these words as they should be interpreted in IETF documents. This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="14"/>
          <seriesInfo name="RFC" value="2119"/>
          <seriesInfo name="DOI" value="10.17487/RFC2119"/>
        </reference>
        <reference anchor="RFC2865" target="https://www.rfc-editor.org/info/rfc2865" quoteTitle="true" derivedAnchor="RFC2865">
          <front>
            <title>Remote Authentication Dial In User Service (RADIUS)</title>
            <author fullname="C. Rigney" initials="C." surname="Rigney"/>
            <author fullname="S. Willens" initials="S." surname="Willens"/>
            <author fullname="A. Rubens" initials="A." surname="Rubens"/>
            <author fullname="W. Simpson" initials="W." surname="Simpson"/>
            <date month="June" year="2000"/>
            <abstract>
              <t indent="0">This document describes a protocol for carrying authentication, authorization, and configuration information between a Network Access Server which desires to authenticate its links and a shared Authentication Server. [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="2865"/>
          <seriesInfo name="DOI" value="10.17487/RFC2865"/>
        </reference>
        <reference anchor="RFC4279" target="https://www.rfc-editor.org/info/rfc4279" quoteTitle="true" derivedAnchor="RFC4279">
          <front>
            <title>Pre-Shared Key Ciphersuites for Transport Layer Security (TLS)</title>
            <author fullname="P. Eronen" initials="P." role="editor" surname="Eronen"/>
            <author fullname="H. Tschofenig" initials="H." role="editor" surname="Tschofenig"/>
            <date month="December" year="2005"/>
            <abstract>
              <t indent="0">This document specifies three sets of new ciphersuites for the Transport Layer Security (TLS) protocol to support authentication based on pre-shared keys (PSKs). These pre-shared keys are symmetric keys, shared in advance among the communicating parties. The first set of ciphersuites uses only symmetric key operations for authentication. The second set uses a Diffie-Hellman exchange authenticated with a pre-shared key, and the third set combines public key authentication of the server with pre-shared key authentication of the client. [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="4279"/>
          <seriesInfo name="DOI" value="10.17487/RFC4279"/>
        </reference>
        <reference anchor="RFC6614" target="https://www.rfc-editor.org/info/rfc6614" quoteTitle="true" derivedAnchor="RFC6614">
          <front>
            <title>Transport Layer Security (TLS) Encryption for RADIUS</title>
            <author fullname="S. Winter" initials="S." surname="Winter"/>
            <author fullname="M. McCauley" initials="M." surname="McCauley"/>
            <author fullname="S. Venaas" initials="S." surname="Venaas"/>
            <author fullname="K. Wierenga" initials="K." surname="Wierenga"/>
            <date month="May" year="2012"/>
            <abstract>
              <t indent="0">This document specifies a transport profile for RADIUS using Transport Layer Security (TLS) over TCP as the transport protocol. This enables dynamic trust relationships between RADIUS servers. [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6614"/>
          <seriesInfo name="DOI" value="10.17487/RFC6614"/>
        </reference>
        <reference anchor="RFC7360" target="https://www.rfc-editor.org/info/rfc7360" quoteTitle="true" derivedAnchor="RFC7360">
          <front>
            <title>Datagram Transport Layer Security (DTLS) as a Transport Layer for RADIUS</title>
            <author fullname="A. DeKok" initials="A." surname="DeKok"/>
            <date month="September" year="2014"/>
            <abstract>
              <t indent="0">The RADIUS protocol defined in RFC 2865 has limited support for authentication and encryption of RADIUS packets. The protocol transports data in the clear, although some parts of the packets can have obfuscated content. Packets may be replayed verbatim by an attacker, and client-server authentication is based on fixed shared secrets. This document specifies how the Datagram Transport Layer Security (DTLS) protocol may be used as a fix for these problems. It also describes how implementations of this proposal can coexist with current RADIUS systems.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7360"/>
          <seriesInfo name="DOI" value="10.17487/RFC7360"/>
        </reference>
        <reference anchor="RFC8174" target="https://www.rfc-editor.org/info/rfc8174" quoteTitle="true" derivedAnchor="RFC8174">
          <front>
            <title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
            <author fullname="B. Leiba" initials="B." surname="Leiba"/>
            <date month="May" year="2017"/>
            <abstract>
              <t indent="0">RFC 2119 specifies common key words that may be used in protocol specifications. This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the defined special meanings.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="14"/>
          <seriesInfo name="RFC" value="8174"/>
          <seriesInfo name="DOI" value="10.17487/RFC8174"/>
        </reference>
        <reference anchor="RFC8265" target="https://www.rfc-editor.org/info/rfc8265" quoteTitle="true" derivedAnchor="RFC8265">
          <front>
            <title>Preparation, Enforcement, and Comparison of Internationalized Strings Representing Usernames and Passwords</title>
            <author fullname="P. Saint-Andre" initials="P." surname="Saint-Andre"/>
            <author fullname="A. Melnikov" initials="A." surname="Melnikov"/>
            <date month="October" year="2017"/>
            <abstract>
              <t indent="0">This document describes updated methods for handling Unicode strings representing usernames and passwords. The previous approach was known as SASLprep (RFC 4013) and was based on Stringprep (RFC 3454). The methods specified in this document provide a more sustainable approach to the handling of internationalized usernames and passwords. This document obsoletes RFC 7613.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8265"/>
          <seriesInfo name="DOI" value="10.17487/RFC8265"/>
        </reference>
        <reference anchor="RFC9257" target="https://www.rfc-editor.org/info/rfc9257" quoteTitle="true" derivedAnchor="RFC9257">
          <front>
            <title>Guidance for External Pre-Shared Key (PSK) Usage in TLS</title>
            <author fullname="R. Housley" initials="R." surname="Housley"/>
            <author fullname="J. Hoyland" initials="J." surname="Hoyland"/>
            <author fullname="M. Sethi" initials="M." surname="Sethi"/>
            <author fullname="C. A. Wood" initials="C. A." surname="Wood"/>
            <date month="July" year="2022"/>
            <abstract>
              <t indent="0">This document provides usage guidance for external Pre-Shared Keys (PSKs) in Transport Layer Security (TLS) 1.3 as defined in RFC 8446. It lists TLS security properties provided by PSKs under certain assumptions, then it demonstrates how violations of these assumptions lead to attacks. Advice for applications to help meet these assumptions is provided. This document also discusses PSK use cases and provisioning processes. Finally, it lists the privacy and security properties that are not provided by TLS 1.3 when external PSKs are used.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="9257"/>
          <seriesInfo name="DOI" value="10.17487/RFC9257"/>
        </reference>
        <reference anchor="RFC9325" target="https://www.rfc-editor.org/info/rfc9325" quoteTitle="true" derivedAnchor="RFC9325">
          <front>
            <title>Recommendations for Secure Use of Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)</title>
            <author fullname="Y. Sheffer" initials="Y." surname="Sheffer"/>
            <author fullname="P. Saint-Andre" initials="P." surname="Saint-Andre"/>
            <author fullname="T. Fossati" initials="T." surname="Fossati"/>
            <date month="November" year="2022"/>
            <abstract>
              <t indent="0">Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS) are used to protect data exchanged over a wide range of application protocols and can also form the basis for secure transport protocols. Over the years, the industry has witnessed several serious attacks on TLS and DTLS, including attacks on the most commonly used cipher suites and their modes of operation. This document provides the latest recommendations for ensuring the security of deployed services that use TLS and DTLS. These recommendations are applicable to the majority of use cases.</t>
              <t indent="0">RFC 7525, an earlier version of the TLS recommendations, was published when the industry was transitioning to TLS 1.2. Years later, this transition is largely complete, and TLS 1.3 is widely available. This document updates the guidance given the new environment and obsoletes RFC 7525. In addition, this document updates RFCs 5288 and 6066 in view of recent attacks.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="195"/>
          <seriesInfo name="RFC" value="9325"/>
          <seriesInfo name="DOI" value="10.17487/RFC9325"/>
        </reference>
      </references>
      <references anchor="sec-informative-references" pn="section-10.2">
        <name slugifiedName="name-informative-references">Informative References</name>
        <reference anchor="RFC5489" target="https://www.rfc-editor.org/info/rfc5489" quoteTitle="true" derivedAnchor="RFC5489">
          <front>
            <title>ECDHE_PSK Cipher Suites for Transport Layer Security (TLS)</title>
            <author fullname="M. Badra" initials="M." surname="Badra"/>
            <author fullname="I. Hajjeh" initials="I." surname="Hajjeh"/>
            <date month="March" year="2009"/>
            <abstract>
              <t indent="0">This document extends RFC 4279, RFC 4492, and RFC 4785 and specifies a set of cipher suites that use a pre-shared key (PSK) to authenticate an Elliptic Curve Diffie-Hellman exchange with Ephemeral keys (ECDHE). These cipher suites provide Perfect Forward Secrecy (PFS). This memo provides information for the Internet community.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="5489"/>
          <seriesInfo name="DOI" value="10.17487/RFC5489"/>
        </reference>
        <reference anchor="RFC6613" target="https://www.rfc-editor.org/info/rfc6613" quoteTitle="true" derivedAnchor="RFC6613">
          <front>
            <title>RADIUS over TCP</title>
            <author fullname="A. DeKok" initials="A." surname="DeKok"/>
            <date month="May" year="2012"/>
            <abstract>
              <t indent="0">The Remote Authentication Dial-In User Server (RADIUS) protocol has, until now, required the User Datagram Protocol (UDP) as the underlying transport layer. This document defines RADIUS over the Transmission Control Protocol (RADIUS/TCP), in order to address handling issues related to RADIUS over Transport Layer Security (RADIUS/TLS). It permits TCP to be used as a transport protocol for RADIUS only when a transport layer such as TLS or IPsec provides confidentiality and security. This document defines an Experimental Protocol for the Internet community.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6613"/>
          <seriesInfo name="DOI" value="10.17487/RFC6613"/>
        </reference>
        <reference anchor="RFC7542" target="https://www.rfc-editor.org/info/rfc7542" quoteTitle="true" derivedAnchor="RFC7542">
          <front>
            <title>The Network Access Identifier</title>
            <author fullname="A. DeKok" initials="A." surname="DeKok"/>
            <date month="May" year="2015"/>
            <abstract>
              <t indent="0">In order to provide inter-domain authentication services, it is necessary to have a standardized method that domains can use to identify each other's users. This document defines the syntax for the Network Access Identifier (NAI), the user identifier submitted by the client prior to accessing resources. This document is a revised version of RFC 4282. It addresses issues with international character sets and makes a number of other corrections to RFC 4282.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7542"/>
          <seriesInfo name="DOI" value="10.17487/RFC7542"/>
        </reference>
        <reference anchor="RFC7585" target="https://www.rfc-editor.org/info/rfc7585" quoteTitle="true" derivedAnchor="RFC7585">
          <front>
            <title>Dynamic Peer Discovery for RADIUS/TLS and RADIUS/DTLS Based on the Network Access Identifier (NAI)</title>
            <author fullname="S. Winter" initials="S." surname="Winter"/>
            <author fullname="M. McCauley" initials="M." surname="McCauley"/>
            <date month="October" year="2015"/>
            <abstract>
              <t indent="0">This document specifies a means to find authoritative RADIUS servers for a given realm. It is used in conjunction with either RADIUS over Transport Layer Security (RADIUS/TLS) or RADIUS over Datagram Transport Layer Security (RADIUS/DTLS).</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7585"/>
          <seriesInfo name="DOI" value="10.17487/RFC7585"/>
        </reference>
        <reference anchor="RFC8442" target="https://www.rfc-editor.org/info/rfc8442" quoteTitle="true" derivedAnchor="RFC8442">
          <front>
            <title>ECDHE_PSK with AES-GCM and AES-CCM Cipher Suites for TLS 1.2 and DTLS 1.2</title>
            <author fullname="J. Mattsson" initials="J." surname="Mattsson"/>
            <author fullname="D. Migault" initials="D." surname="Migault"/>
            <date month="September" year="2018"/>
            <abstract>
              <t indent="0">This document defines several new cipher suites for version 1.2 of the Transport Layer Security (TLS) protocol and version 1.2 of the Datagram Transport Layer Security (DTLS) protocol. These cipher suites are based on the Ephemeral Elliptic Curve Diffie-Hellman with Pre-Shared Key (ECDHE_PSK) key exchange together with the Authenticated Encryption with Associated Data (AEAD) algorithms AES-GCM and AES-CCM. PSK provides light and efficient authentication, ECDHE provides forward secrecy, and AES-GCM and AES-CCM provide encryption and integrity protection.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8442"/>
          <seriesInfo name="DOI" value="10.17487/RFC8442"/>
        </reference>
        <reference anchor="RFC8446" target="https://www.rfc-editor.org/info/rfc8446" quoteTitle="true" derivedAnchor="RFC8446">
          <front>
            <title>The Transport Layer Security (TLS) Protocol Version 1.3</title>
            <author fullname="E. Rescorla" initials="E." surname="Rescorla"/>
            <date month="August" year="2018"/>
            <abstract>
              <t indent="0">This document specifies version 1.3 of the Transport Layer Security (TLS) protocol. TLS allows client/server applications to communicate over the Internet in a way that is designed to prevent eavesdropping, tampering, and message forgery.</t>
              <t indent="0">This document updates RFCs 5705 and 6066, and obsoletes RFCs 5077, 5246, and 6961. This document also specifies new requirements for TLS 1.2 implementations.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8446"/>
          <seriesInfo name="DOI" value="10.17487/RFC8446"/>
        </reference>
        <reference anchor="RFC8492" target="https://www.rfc-editor.org/info/rfc8492" quoteTitle="true" derivedAnchor="RFC8492">
          <front>
            <title>Secure Password Ciphersuites for Transport Layer Security (TLS)</title>
            <author fullname="D. Harkins" initials="D." role="editor" surname="Harkins"/>
            <date month="February" year="2019"/>
            <abstract>
              <t indent="0">This memo defines several new ciphersuites for the Transport Layer Security (TLS) protocol to support certificateless, secure authentication using only a simple, low-entropy password. The exchange is called "TLS-PWD". The ciphersuites are all based on an authentication and key exchange protocol, named "dragonfly", that is resistant to offline dictionary attacks.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8492"/>
          <seriesInfo name="DOI" value="10.17487/RFC8492"/>
        </reference>
        <reference anchor="RFC8937" target="https://www.rfc-editor.org/info/rfc8937" quoteTitle="true" derivedAnchor="RFC8937">
          <front>
            <title>Randomness Improvements for Security Protocols</title>
            <author fullname="C. Cremers" initials="C." surname="Cremers"/>
            <author fullname="L. Garratt" initials="L." surname="Garratt"/>
            <author fullname="S. Smyshlyaev" initials="S." surname="Smyshlyaev"/>
            <author fullname="N. Sullivan" initials="N." surname="Sullivan"/>
            <author fullname="C. Wood" initials="C." surname="Wood"/>
            <date month="October" year="2020"/>
            <abstract>
              <t indent="0">Randomness is a crucial ingredient for Transport Layer Security (TLS) and related security protocols. Weak or predictable "cryptographically secure" pseudorandom number generators (CSPRNGs) can be abused or exploited for malicious purposes. An initial entropy source that seeds a CSPRNG might be weak or broken as well, which can also lead to critical and systemic security problems. This document describes a way for security protocol implementations to augment their CSPRNGs using long-term private keys. This improves randomness from broken or otherwise subverted CSPRNGs.</t>
              <t indent="0">This document is a product of the Crypto Forum Research Group (CFRG) in the IRTF.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8937"/>
          <seriesInfo name="DOI" value="10.17487/RFC8937"/>
        </reference>
        <reference anchor="RFC9258" target="https://www.rfc-editor.org/info/rfc9258" quoteTitle="true" derivedAnchor="RFC9258">
          <front>
            <title>Importing External Pre-Shared Keys (PSKs) for TLS 1.3</title>
            <author fullname="D. Benjamin" initials="D." surname="Benjamin"/>
            <author fullname="C. A. Wood" initials="C. A." surname="Wood"/>
            <date month="July" year="2022"/>
            <abstract>
              <t indent="0">This document describes an interface for importing external Pre-Shared Keys (PSKs) into TLS 1.3.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="9258"/>
          <seriesInfo name="DOI" value="10.17487/RFC9258"/>
        </reference>
      </references>
    </references>
    <section anchor="acknowledgments" numbered="false" removeInRFC="false" toc="include" pn="section-appendix.a">
      <name slugifiedName="name-acknowledgments">Acknowledgments</name>
      <t indent="0" pn="section-appendix.a-1">Thanks to the many reviewers in the RADEXT Working Group for positive
      feedback.</t>
    </section>
    <section anchor="authors-addresses" numbered="false" removeInRFC="false" toc="include" pn="section-appendix.b">
      <name slugifiedName="name-authors-address">Author's Address</name>
      <author initials="A." surname="DeKok" fullname="Alan DeKok">
        <organization showOnFrontPage="true">InkBridge Networks</organization>
        <address>
          <email>alan.dekok@inkbridge.io</email>
        </address>
      </author>
    </section>
  </back>
</rfc>
